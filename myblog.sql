/*
 Navicat Premium Data Transfer

 Source Server         : 情比金坚锁
 Source Server Type    : MySQL
 Source Server Version : 80026
 Source Host           : 182.92.67.46:2333
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 80026
 File Encoding         : 65001

 Date: 24/08/2022 21:32:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for about
-- ----------------------------
DROP TABLE IF EXISTS `about`;
CREATE TABLE `about`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of about
-- ----------------------------
INSERT INTO `about` VALUES (1, 'http://182.92.67.46/demo/21/');

-- ----------------------------
-- Table structure for admin
-- ----------------------------
DROP TABLE IF EXISTS `admin`;
CREATE TABLE `admin`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `loginId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `loginPwd` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of admin
-- ----------------------------
INSERT INTO `admin` VALUES (1, 'admin', '超级管理员', '9a0886fed98dc7cabb241dac0f939791');

-- ----------------------------
-- Table structure for banner
-- ----------------------------
DROP TABLE IF EXISTS `banner`;
CREATE TABLE `banner`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `midImg` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `bigImg` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of banner
-- ----------------------------
INSERT INTO `banner` VALUES (1, '/static/images/minChildLF.png', '/static/images/childLF.png', '蒙奇·D·路飞(モンキー・D・ルフィ)', '海贼王，我当定了！');
INSERT INTO `banner` VALUES (2, '/static/images/minRoronoaZoro.png', '/static/images/RoronoaZoro.png', '罗罗诺亚·索隆(ロロノア・ゾロ)', '请把那把刀给我吧！我要会连她的份也一起努力的，我要成为世界第一的大剑客，我要让我的名字，响彻天堂！');
INSERT INTO `banner` VALUES (3, '/static/images/minLfWife.png', '/static/images/lfWife.png', '波雅·汉库克(ボア・ハンコック)', '男人?同伴还是敌人都一样!但...他(路飞)除外。');

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `description` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `toc` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `htmlContent` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `thumb` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `scanNumber` int(0) NOT NULL,
  `commentNumber` int(0) NOT NULL,
  `createDate` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `categoryId` int(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `categoryId`(`categoryId`) USING BTREE,
  CONSTRAINT `blog_ibfk_1` FOREIGN KEY (`categoryId`) REFERENCES `blogType` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (1, '文档声明', '*HTML* 文档通常以文档声明开始，该声明的作用是帮助浏览器确定其尝试解析和显示的 *HTML* 文档类型。', '[{\"name\":\"文档声明\",\"anchor\":\"文档声明\",\"level\":1,\"children\":[{\"name\":\"文档声明概念\",\"anchor\":\"文档声明概念\",\"level\":2,\"children\":[]},{\"name\":\"渲染模式\",\"anchor\":\"渲染模式\",\"level\":2,\"children\":[]}]}]', '<h1 id=\"文档声明\">文档声明</h1><h2 id=\"文档声明概念\">文档声明概念</h2><p><em>HTML</em> 文档通常以文档声明开始，该声明的作用是帮助浏览器确定其尝试解析和显示的 <em>HTML</em> 文档类型。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;</code></pre></div><p>文档声明必须是 <em>HTML</em> 文档的第一行、且顶格显示，对大小写不敏感。因为任何放在 <em>DOCTYPE</em> 前面的东西，比如批注或 <em>XML</em> 声明，会令 <em>IE9</em> 或更早期的浏览器触发怪异模式（后面的渲染模式会介绍）</p><p><br></p><p>文档声明并非一个 <em>HTML</em> 标签。它是一条“信息”，告知浏览器期望的文档类型。</p><p><br></p><p>那么说到文档类型，我们首先有必要先了解一下 <em>HTML</em> 的发展历史。如下图所示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-020539.png\" alt=\"image-20210907100539198\" contenteditable=\"false\"><br></p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-020626.png\" alt=\"image-20210907100626110\" contenteditable=\"false\"><br></p><p><br></p><p>可以看到，<em>HTML</em> 版本从最开始诞生到最新的 <em>HTML5</em>，中间经历了很多版本。</p><p><br></p><p>那不同的版本有啥区别么？当然有区别，比如一个最显著的区别就是支持的 <em>HTML</em> 元素不同。例如：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-021238.png\" alt=\"image-20210907101237957\" contenteditable=\"false\"><br></p><blockquote><p>更多各版本所支持的不同 <em>HTML</em> 元素可以参阅：<em>https://www.w3school.com.cn/tags/html_ref_dtd.asp</em></p></blockquote><p>现在就知道为什么要书写文档声明了。原因是不同版本所支持的 <em>HTML</em> 元素类型是不同的，我需要告诉浏览器以哪一种文档类型方式来解析当前的这个 <em>HTML</em> 文件。</p><p><br></p><p>那么，最新的 <em>HTML5</em> 的文档类型倒是很简单，前面已经看到了</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;</code></pre></div><p>那么稍微老一点的版本，例如 <em>HTML4</em> 或 <em>XHTML</em> 的文档类型声明长啥样呢？</p><p><br></p><p>这里来看两个。</p><p><br></p><p><strong><em>HTML 4.01 Strict</em></strong></p><p><br></p><p>该 <em>DTD</em> 包含所有 <em>HTML</em> 元素和属性，但不包括展示性的和弃用的元素（比如 <em>font</em>）。不允许框架集（<em>Framesets</em>）。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"&gt;</code></pre></div><p><strong><em>HTML 4.01 Transitional</em></strong></p><p><br></p><p>该 <em>DTD</em> 包含所有 <em>HTML</em> 元素和属性，包括展示性的和弃用的元素（比如 <em>font</em>）。不允许框架集（<em>Framesets</em>）。</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \n\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</code></pre></div><blockquote><p>更多不同文档类型的声明写法可以参阅：<em>https://www.w3school.com.cn/tags/tag_doctype.asp</em></p></blockquote><p>首先，给我的第一直观感受，就是声明写得很长。</p><p><br></p><p>那么为什么会这么长呢？</p><p><br></p><p>原因是，<em>HTML5</em> 不需要引入 <em>DTD</em> 文件，而其他类型的文档声明是需要引入 <em>DTD</em> 的。</p><p><br></p><p>这里出现了,一个新的名词出现了，<em>DTD</em>。</p><p><br></p><p>在早期的 <em>HTML</em> 版本，例如 <em>HTML 4.01</em> 中，<em>&lt;!DOCTYPE&gt;</em> 声明之所以要引用 <em>DTD</em>，是因为 <em>HTML 4.01</em> 基于 <em>SGML</em>。而 <em>DTD</em> 规定的是标记语言的规则，这样浏览器才能正确地呈现内容。</p><p><br></p><p>但是最新的 <em>HTML5</em> 不基于 <em>SGML</em>，所以不需要引用 <em>DTD</em>。</p><p><br></p><p>到这里又冒出来一个 <em>SGML</em> ？？</p><p><br></p><p>是的，你没有看错，我们有：<em>SGML、HTML、XML、XHTML、HTML5</em></p><p><br></p><p>从这五者的名字中，我们都可以看到 “<em>ML</em>” 这两个字母，所以我们先从 “<em>ML</em>” 说起。</p><p><br></p><p>“<em>ML</em>”即 “<em>Markup language</em>(置标语言)”。</p><p><br></p><p>根据维基百科对其的解释，“<em>Markup language</em>” 是用标准的标记来解释纯文本文档的内容，从而提供关于文档结构或文档该如何渲染的信息。置标语言的发展可以用下图来表示：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-023423.png\" alt=\"image-20210907103423285\" contenteditable=\"false\"><br></p><p><br></p><p><em>GML</em> 是第一代置标语言，使文档能明确将标示和内容分开，所有文件使用同样的标示方法。</p><p><br></p><p><em>SGML</em> 在 <em>GML</em> 的基础上进行整理，形成了一套非常严谨的文件描述方法。它的组成包括语法定义，<em>DTD</em>，文件实例三部分。<em>SGML</em> 因太严谨规范达 <em>500</em> 多页，故而不易学、不易用、难以实现，所以在它的基础上又发展出了其他的更易用的置标语言。</p><p><br></p><p><em>HTML</em> 抛弃了<em>SGML</em> 复杂庞大的缺点，继承了 <em>SGML</em> 的很多优点。<em>HTML</em> 最大的特点是简单性和跨平台性。它只使用了 <em>SGML</em> 中很少的一部分标记，例如 <em>HTML 4.0</em> 中只定义了 <em>70</em> 余种标记。为了便于在计算机上实现，<em>HTML</em> 规定的标记是固定的，即 <em>HTML</em> 语法是不可扩展的。</p><p><br></p><p>随着 <em>Web</em> 应用的不断发展，<em>HTML</em> 的局限性也越来越明显地显现了出来，如 <em>HTML</em> 无法描述数据、可读性差、搜索时间长等。人们又把目光转向 <em>SGML</em>，再次改造 <em>SGML</em> 使之适应现在的网络需求。<em>1998</em> 年 <em>2</em> 月 <em>10</em> 日，<em>W3C</em>(<em>World Wide Web Consortium</em>，万维网联盟)公布 <em>XML 1.0</em> 标准，<em>XML</em> 诞生了。很长一段时间，<em>XML</em> 都作为网络传输的标准数据格式。</p><p><br></p><p><em>XHTML</em> 的出现是因为当时的 <em>HTML</em> 语法要求比较松散，这样对网页编写者来说，比较方便，但对于机器来说，语言的语法越松散，处理起来就越困难，对于传统的计算机来说，还有能力兼容松散语法，但对于许多其他设备，比如手机，难度就比较大。因此产生了由 <em>DTD</em> 定义规则，语法要求更加严格的 <em>XHTML</em>。</p><blockquote><p><em>DTD</em> 教程可以参阅：<em>https://www.w3school.com.cn/dtd/index.asp</em></p></blockquote><p>最终，<em>HTML5</em> 是 <em>HTML</em> 的第五个修订版，该版本不在基于 <em>SGML</em> 了，所以也就不用再引入 <em>DTD</em> 声明了。</p><p><br></p><p><em>HTML5</em> 的出现，其主要的目标是将互联网语义化，以便更好地被人类和机器阅读，并同时提供更好地支持各种媒体的嵌入。</p><p><br></p><p>现在国内通常所说的 <em>H5</em> 开发，实际上是 <em>HTML5</em> 与 <em>CSS3</em> 及 <em>ES6</em> 的一个组合，大概可以用以下公式说明：<em>HTML5 ≈ HTML + CSS3 + ES6</em></p><h2 id=\"渲染模式\">渲染模式</h2><p>明白了文档类型声明的作用之后，接下来我们还需要看一个东西，那就是渲染模式。</p><p><br></p><p>浏览器渲染模式分为 <em>3</em> 种：</p><ul><li><p>怪癖模式（混杂模式）[<em>Quirks mode</em>]</p></li><li><p>严格模式（标准模式） [<em>Standars mode</em>]</p></li><li><p>几乎标准模式 [<em>Almost standards mode</em>]</p></li></ul><blockquote><p>之所以出现不同的渲染模式，是由于历史原因造成的。</p><p><br></p><p>当年 <em>Netscape4</em>（网景公司早期的浏览器）和 <em>IE4</em>（微软公司早期的浏览器）实现 <em>CSS</em> 机制时，没有遵循 <em>W3C</em> 提出的标准。<em>Netscape4</em> 提供了糟糕的支持，而 <em>IE4</em> 虽然接近标准，但依旧未能完全正确的支持标准。</p><p><br></p><p>所以，在 <em>W3C</em> 标准推出以前，浏览器在对页面的渲染上没有统一规范，产生了差异（<em>Quirks mode</em> 或者称为 <em>Compatibility Mode</em>）</p><p><br></p><p>为了保障自己的网站在各个浏览器上显示正确，网页开发者们不得不依据各个浏览器自身的规范来使用 <em>CSS</em>，因此大部分网站的 <em>CSS</em> 实现并不符合 <em>W3C</em> 规范的标准。</p><p><br></p><p><em>W3C</em> 标准推出后，浏览器渲染页面有了统一的标准（<em>Strict mode</em> 也有叫做 <em>Standars mode</em>）浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。</p><p><br></p><p>为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的 <em>IE</em>）。这样浏览器渲染上就产生了 <em>Quircks mode</em> 和 <em>Standars mode</em>，两种渲染方法共存在一个浏览器上。混杂模式服务于旧式规则，而严格模式服务于标准规则。</p></blockquote><p>对于 <em>HTML</em> 文档来说，浏览器使用文档开头的 <em>DOCTYPE</em> 来决定用怪异模式处理或标准模式处理。</p><p><br></p><p>如果文档中没有 <em>DOCTYPE</em> 将触发文档的怪异模式。怪异模式最明显的影响是会触发怪异盒模型。</p><p><br></p><p>在 <em>DOCTYPE</em> 声明中，没有使用 <em>DTD</em> 声明或者使用 <em>HTML4</em> 以下的 <em>DTD</em> 声明时，基本所有的浏览器都是使用 <em>Quirks mode</em> 呈现，其他的则使用 <em>Standars mode</em> 解析。</p><p><br></p><p><strong>严格模式和怪异模式的部分渲染区别</strong></p><ol><li><p>盒模型的高宽包含内边距 <em>padding</em> 和边框 <em>border</em></p></li></ol><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-035904.png\" alt=\"img\" contenteditable=\"false\"><br></p><p><br></p><p>在 <em>W3C</em> 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 <em>IE5.5</em> 及以下的浏览器及其他版本的 <em>Quirks</em> 模式下，<em>IE</em> 的宽度和高度还包含了 <em>padding</em> 和 <em>border</em>。</p><ol start=\"2\"><li><p>可以设置行内元素的高宽</p></li></ol><p>在 <em>standards</em> 模式下，给 <em>span</em> 等行内元素设置 <em>wdith</em> 和 <em>height</em> 都不会生效，而在 <em>Quirks</em> 模式下，则会生效。</p><ol start=\"3\"><li><p>可设置百分比的高度</p></li></ol><p>在 <em>standards</em> 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</p><ol start=\"4\"><li><p>用 <em>margin:0 auto</em> 设置水平居中在 <em>IE</em> 下会失效</p></li></ol><p>使用 <em>margin:0 auto</em> 在 <em>standards</em> 模式下可以使元素水平居中，但在 <em>Quirks</em> 模式下却会失效，<em>Quirks</em> 模式下的解决办法，用 <em>text-align</em> 属性：<em>body{text-align:center};#content{text-align:left}</em></p><ol start=\"5\"><li><p><em>Quirks</em> 模式下设置图片的 <em>padding</em> 会失效</p></li><li><p><em>Quirks</em> 模式下 <em>Table</em> 中的字体属性不能继承上层的设置</p></li><li><p><em>Quirks</em> 模式下 <em>white-space:pre</em> 会失效</p></li></ol><blockquote><p>更多可以参阅 <em>MDN</em> 上对怪异模式和标准模式的解释：<em>https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode</em></p></blockquote><blockquote><p><em>MDN</em> 上还给出了不同模式在不同浏览器下的渲染区别（英文）：<em>https://hsivonen.fi/doctype/</em></p></blockquote><p>-<em>EOF</em>-</p>', '/static/uploads/006Mi9iRgy1gsoykmf20ug306805a3yh16613035507158423.gif', 73, 0, '1581478208000', 5);
INSERT INTO `blog` VALUES (2, '语义化', '语义是指对一个词或者句子含义的正确解释。很多 *HTML* 标签也具有语义的意义，也就是说元素本身传达了关于标签所包含内容类型的一些信息。', '[{\"name\":\"什么是语义元素？\",\"anchor\":\"什么是语义元素\",\"level\":2,\"children\":[]},{\"name\":\"为什么要语义化？\",\"anchor\":\"为什么要语义化\",\"level\":2,\"children\":[]},{\"name\":\"*HTML5* 常用的语义元素\",\"anchor\":\"html5-常用的语义元素\",\"level\":2,\"children\":[]},{\"name\":\"无障碍网页\",\"anchor\":\"无障碍网页\",\"level\":2,\"children\":[]}]', '<h2 id=\"什么是语义元素\">什么是语义元素？</h2><p>语义是指对一个词或者句子含义的正确解释。很多 <em>HTML</em> 标签也具有语义的意义，也就是说元素本身传达了关于标签所包含内容类型的一些信息。例如，当浏览器解析到<code data-backticks=\"1\">&lt;h1&gt;&lt;/h1&gt;</code>标签时，它将该标签解释为包含这一块内容的最重要的标题。<em>h1</em> 标签的语义就是用它来标识特定网页或部分最重要的标题。</p><h2 id=\"为什么要语义化\">为什么要语义化？</h2><ul><li><p>代码结构：使页面没有css的情况下，也能够呈现出很好的内容结构</p></li><li><p>有利于 <em>SEO</em>： 爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息</p></li><li><p>提升用户体验：例如 <em>title、alt</em> 可以用于解释名称或者解释图片信息，以及 <em>label</em> 标签的灵活运用。</p></li><li><p>便于团队开发和维护：语义化使得代码更具有可读性，让其他开发人员更加理解你的 <em>html</em> 结构，减少差异化。</p></li><li><p>方便其他设备解析：如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。</p></li></ul><h2 id=\"html5-常用的语义元素\"><em>HTML5</em> 常用的语义元素</h2><p><em>HTML5</em> 提供了新的语义元素来定义网页的不同部分，它们被称为“切片元素”，如图所示 ：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-062515.png\" alt=\"image-20210907142515375\" contenteditable=\"false\"><br></p><ul><li><p><em>header</em>：用于定义页面的头部区域，通常包括网站 <em>logo</em>、主导航、全站链接以及搜索框。</p></li><li><p><em>nav</em>：定义页面的导航链接部分区域。</p></li><li><p><em>main</em>：定义文档的主要内容，该内容在文档中应当是独一无二的</p></li><li><p><em>article</em>：定义页面独立的内容，它可以有自己的 <em>header、footer、sections</em> 等，专注于单个主题的博客文章，报纸文章或网页文章。</p></li><li><p><em>section</em>：表示文档中的一个区域（或节），比如，内容中的一个专题组。</p></li><li><p><em>aside</em>：表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分且可以被单独的拆分出来而不会影响整体。通常表现为侧边栏或嵌入内容。</p></li><li><p><em>footer</em>：定义最近一个章节内容或者根节点元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p></li></ul><p>大约有 <em>100</em> 多个 <em>HTML</em> 语义元素可供选择，以下是常用的语义元素：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-07-062552.png\" alt=\"image-20210907142551909\" contenteditable=\"false\"><br></p><blockquote><p>更多的语义化标签可以参阅：<em>https://developer.mozilla.org/en-US/docs/Web/HTML/Element</em></p></blockquote><h2 id=\"无障碍网页\">无障碍网页</h2><p><em>W3C</em> 在 <em>1997</em> 年发起了一项 <em>WAI</em>（<em>Web Accessibility Initiative</em>）的计划，该计划的目标是提升网站的易用性(<em>accessibility</em>)，而其中有一个很重要的指标，那就是能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。</p><p><br></p><p><em>HTML5</em> 在无障碍方面进行了加强，加入了无障碍属性。</p><p><br></p><p>所谓 <em>HTML5</em> 无障碍属性，主要针对的是视觉缺陷，失聪，行动不便的残疾人以及假装残疾的测试人员。尤其像盲人，眼睛看不到，其浏览网页则需要借助辅助设备，如屏幕阅读器，屏幕阅读机可以大声朗读或者输出盲文。</p><p><br></p><p>而 <em>HTML5</em> 无障碍属性就是可以让屏幕阅读器准确识别网页中的内容，变化，状态的技术规范，可以让盲人这类用户也能无障碍阅读！</p><blockquote><p>关于无障碍的更多说明，可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/Accessibility</em></p></blockquote><p><strong>常见的无障碍属性</strong></p><p><br></p><p><em>WAI-ARIA</em> 是 <em>W3C</em> 编写的规范，定义了一组可用于其他元素的 <em>HTML</em> 特性，用于提供额外的语义化以及改善缺乏的可访问性。以下是规范中三个主要的特性：</p><ul><li><p>角色：这定义了元素是干什么的。许多「标志性的角色」，其实重复了 <em>HTML5</em> 的结构元素的语义价值。例如 <em>role=\"navigation\"</em> (<em>nav</em>) 或者 <em>role=\"complementary\"</em> (<em>aside</em>)。</p></li><li><p>属性：我们能通过定义一些属性给元素，让他们具备更多的语义。例如：<em>aria-required=\"true\"</em> 意味着元素在表单上是必填的。然而 <em>aria-labelledby=\"label\"</em> 允许在元素上设置一个 <em>ID</em>，用于 <em>labelledby</em> 引用作为屏幕阅读器指定的 <em>label</em> 内容 ，多个也可以。</p></li><li><p>状态：用于表达元素当前的条件的特殊属性，例如 <em>aria-disabled=\"true\"</em>，屏幕阅读器就会这个表单禁止输入。状态和属性的差异之处就是：属性在应用的生命周期中不会改变，而状态可以，通常我们用编程的方法改变它，例如 <em>Javascript</em>。</p></li></ul><p>关于 <em>WAI-ARIA</em> 属性重要的一点是它不会对 <em>Web</em> 页面有任何影响，除了让更多的信息从浏览器暴露给 <em>accessibility APIs</em> (无障碍 <em>API</em>)，这也是屏幕阅读器这一类软件的信息源。<em>WAI-ARIA</em> 不会影响网页的结构，以及 <em>DOM</em> 等等，尽管这些属性可用于作为 <em>CSS</em> 选择器。</p><blockquote><p>更多无障碍属性可以参阅：<em>https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_basics</em></p></blockquote><p>-<em>EOF</em>-</p>', '/static/uploads/006APoFYly8gvwovuy0w2j30hs0hsjs3 (1)16613049700599524.jpg', 10, 0, '1582342208000', 5);
INSERT INTO `blog` VALUES (3, 'SEO', '*SEO* 由英文 *Search Engine Optimization* 缩写而来，中文意译为“搜索引擎优化”。', '[{\"name\":\"什么是 *SEO*？\",\"anchor\":\"什么是-seo\",\"level\":2,\"children\":[]},{\"name\":\"如何进行 *SEO* 优化工作？\",\"anchor\":\"如何进行-seo-优化工作\",\"level\":2,\"children\":[{\"name\":\"内部优化\",\"anchor\":\"内部优化\",\"level\":3,\"children\":[{\"name\":\"1. 合理的 *title、description、keywords*\",\"anchor\":\"1-合理的-titledescriptionkeywords\",\"level\":4,\"children\":[]},{\"name\":\"2. 语义化的 *HTML* 代码，符合 *W3C* 规范\",\"anchor\":\"2-语义化的-html-代码符合-w3c-规范\",\"level\":4,\"children\":[]},{\"name\":\"3. 非装饰性图片必须加 *alt*\",\"anchor\":\"3-非装饰性图片必须加-alt\",\"level\":4,\"children\":[]},{\"name\":\"4. 对于不显示的对象谨慎使用 *display:none*\",\"anchor\":\"4-对于不显示的对象谨慎使用-displaynone\",\"level\":4,\"children\":[]},{\"name\":\"5. 重要内容 *HTML* 代码放在最前\",\"anchor\":\"5-重要内容-html-代码放在最前\",\"level\":4,\"children\":[]},{\"name\":\"6. 少用 *iframe*\",\"anchor\":\"6-少用-iframe\",\"level\":4,\"children\":[]}]},{\"name\":\"外部优化\",\"anchor\":\"外部优化\",\"level\":3,\"children\":[]}]}]', '<h2 id=\"什么是-seo\">什么是 <em>SEO</em>？</h2><p><em>SEO</em> 由英文 <em>Search Engine Optimization</em> 缩写而来，中文意译为“搜索引擎优化”。</p><p><br></p><p>其实叫做针对搜索引擎优化更容易理解。它是指从自然搜索结果获得网站流量的技术和过程，是在了解搜索引擎自然排名机制的基础上，对网站进行内部及外部的调整优化，改进网站在搜索引擎中的关键词自然排名，获得更多流量，从而达成网站销售及品牌建设的目标。</p><h2 id=\"如何进行-seo-优化工作\">如何进行 <em>SEO</em> 优化工作？</h2><p>我的第一反应：给钱。</p><p><br></p><p>虽然，国内的百度搜索引擎，确实存在给钱就把你排在前面的情况，但是在不给钱的情况下，也能够通过一些优化手段来提升页面的权重，从而使页面获取更多流量。</p><p><br></p><p>下面就介绍一些常见的 <em>SEO</em> 优化手段。</p><p><br></p><p>整个 <em>SEO</em> 工作大致可以分为<strong>内部优化</strong>和<strong>外部优化</strong>。</p><h3 id=\"内部优化\">内部优化</h3><h4 id=\"1-合理的-titledescriptionkeywords\">1. 合理的 <em>title、description、keywords</em></h4><p>面试题中经常出现的 <em>TDK</em>，其实就是这 <em>3</em> 个单词的缩写。</p><ul><li><p><em>title</em>：浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到，搜索引擎在抓取网页时，最先读取的就是网页标题，所以 <em>title</em> 是否正确设置极其重要。<em>title</em> 一般不超过 <em>80</em> 个字符，而且词语间要用英文 “-” 隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。</p></li><li><p><em>description</em>：也就是网页的内容摘要，这是对于一个网页的简要内容概况。<em>description</em> 一般不超过 <em>150</em> 个字符，描述内容要和页面内容相关。</p></li><li><p><em>keywords</em>：主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此 <em>keywords</em> 的每个词都要能在内容中找到相应匹配，才有利于排名。<em>keywords</em> 一般不超过 <em>3</em> 个，每个关键词不宜过长，而且词语间要用英文 “,” 隔开，尽量将重要的关键字靠前放。</p></li></ul><h4 id=\"2-语义化的-html-代码符合-w3c-规范\">2. 语义化的 <em>HTML</em> 代码，符合 <em>W3C</em> 规范</h4><p>语义化代码能够让搜索引擎容易理解网页，即使脱去了 <em>CSS</em> 这一层外衣，整个网页的结构也是清清楚楚的，无论是搜索引擎还是阅读者，都能够很容易的分辨网页的结构。</p><p><br></p><p>关于语义化的具体内容，可以参阅《语义化》章节。</p><h4 id=\"3-非装饰性图片必须加-alt\">3. 非装饰性图片必须加 <em>alt</em></h4><p><em>img</em> 标签的 <em>alt</em> 属性指定了替代文本，用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。</p><p><br></p><p>例如：<code data-backticks=\"1\">&lt;img src=\"/xxx.jpg\" alt=\"海尔官网-双门冰箱\" /&gt;</code></p><p><br></p><p><em>alt</em> 标签的作用：</p><ul><li><p>增强内容相关性：它是可以利用汉字介绍文章内容的，对于一些特定的企业产品，由于视觉的体验，它往往是少文字的。</p></li><li><p>提高关键词密度：在操作企业站的时候，我们经常遇到是站点首屏一个大的横幅 <em>banner</em>，几乎占用了首页的大部分页面，为了有效的提高首页核心关键词密度，我们只能利用一切办法增添关键词，比如：在图片的 <em>alt</em> 标签中添加。</p></li></ul><h4 id=\"4-对于不显示的对象谨慎使用-displaynone\">4. 对于不显示的对象谨慎使用 <em>display:none</em></h4><p>对于不想显示的文字内容，应当设置 <em>z-index</em> 或设置到浏览器显示器之外。因为搜索引擎会过滤掉 <em>display:none</em> 其中的内容。</p><h4 id=\"5-重要内容-html-代码放在最前\">5. 重要内容 <em>HTML</em> 代码放在最前</h4><p>索引擎抓取 <em>HTML</em> 顺序是从上到下，所以我们尽量将重要的内容放在前面，保证重要内容一定会被抓取。</p><h4 id=\"6-少用-iframe\">6. 少用 <em>iframe</em></h4><p>少用或者尽量不用 <em>iframe</em>，因为搜索引擎不会抓取 <em>iframe</em> 中的内容</p><p><br></p><p>优化的细节还有很多，更多细节可以参阅这篇博文：<em>https://blog.csdn.net/yanyihan16/article/details/89209436?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control</em></p><h3 id=\"外部优化\">外部优化</h3><p>外部优化主要是指放友情链接和外链。好的友情链接可以快速的提高网站的权重，高质量的外链，会给你的网站提高源源不断的权重提升。另外，就是要向各大搜索引擎登陆入口提交尚未收录站点。</p><p><br></p><p>-<em>EOF</em>-</p>', '/static/uploads/ceeb653ely8gzoktbyo2mj208307z3yr16613055806975002.jpg', 22, 0, '1637465408000', 5);
INSERT INTO `blog` VALUES (4, '渐进式渲染', '渐进式渲染，英文全称 *progressive rendering*，也被称之为惰性渲染，指的是为了提高用户感知的加载速度，以尽快的速度来呈现页面的技术。', '[]', '<p>渐进式渲染，英文全称 <em>progressive rendering</em>，也被称之为惰性渲染，指的是为了提高用户感知的加载速度，以尽快的速度来呈现页面的技术。</p><p><br></p><p>在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。</p><p><br></p><p>有一点需要弄明白的是，这不是指的某一项技术，而是各种技术的一种集合。</p><p><br></p><p>例如：</p><p><br></p><p><strong>骨架屏</strong></p><p><br></p><p>在加载网络数据时，为了提升用户体验，通常会使用一个转圈圈的 <em>loading</em> 动画，或者使用 <em>Skeleton Screen</em> 占位。相比与 <em>loading</em> 动画，<em>Skeleton Screen</em> 的效果要更生动</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-13-081721.png\" alt=\"image-20210913161720022\" contenteditable=\"false\"><br></p><p><br></p><p><strong>图片懒加载</strong></p><p><br></p><p>所谓图片懒加载，顾名思义，就是先加载部分图片，剩余的图片等到需要的时候再加载。这在电商网站中尤其常见。</p><p><br></p><p>比如一个电商网站，首屏通常会有很多的数据，清晰度较高的 <em>banner</em> 或轮播。页面非首屏部分会员很多商品夹杂着大量的图片。这是时候选择懒加载以保证首屏的流畅十分重要。</p><p><br></p><p><strong>图片占位符</strong></p><p><br></p><p>在网页加载的时候，某些图片还在请求中或者还未请求，这个时候就先找一个临时代替的图像，放在最终图像的位置上，但是这只是临时替代的图形，当图片数据准备好以后，会重新渲染真正的图形数据。</p><p><br></p><p><strong>拆分网页资源</strong></p><p><br></p><p>大部分用户不会用到一个网站的所有页面，但我们通常的做法却是把所有的功能都打包进一个很大的文件里面。一个 <em>bundle.js</em> 文件的大小可能会有几  <em>M</em>，一个打包后的  <em>style.css</em>  会包含网站的一切样式，从  <em>CSS</em>  结构定义到网站在各个版本的样式：移动端、平板、桌面、打印版等等。</p><p><br></p><p>但用户并不是一开始就需要所有的资源，所有我们可以对资源进行拆分，首先加载那些关键的资源，其他的资源等到需要的时候再去加载它。</p><p><br></p><p>更多的关于渐进式渲染的内容，可以参阅 <em>MDN</em>：<em>https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Loading</em></p><p><br></p><p>-<em>EOF</em>-</p>', '/static/uploads/006APoFYly8h1g14nrb28g30cg0ciqv9 16613057486419602.gif', 34, 0, '1656819008000', 2);
INSERT INTO `blog` VALUES (5, 'CSS渲染性能优化', '很多人往往不重视性能优化这一块，觉得功能做出来就行了。', '[]', '<p>很多人往往不重视性能优化这一块，觉得功能做出来就行了。</p><p><br></p><p>诚然，在软件开发过程中，功能确实是优先要考虑的，但是当功能完善后，接下来就需要考虑性能问题了。</p><p><br></p><p>我们可以从两个方面来看性能优化的意义：</p><ol><li><p>用户角度</p><p>网站优化能够让页面加载得更快，响应更加及时，极大提升用户体验。</p></li><li><p>服务商角度</p><p>优化会减少页面资源请求数，减小请求资源所占带宽大小，从而节省可观的带宽资源。</p></li></ol><p>网站优化的目标就是减少网站加载时间，提高响应速度。</p><p><br></p><p>那么网站加载速度和用户体验又有着怎样的关系呢？我们来看下面这张图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-041118.png\" alt=\"image-20210916121117684\" contenteditable=\"false\"><br></p><p><br></p><p><em>Google</em> 和亚马逊的研究表明，<em>Google</em> 页面加载的时间从 <em>0.4</em> 秒提升到 <em>0.9</em> 秒导致丢失了 <em>20%</em> 流量和广告收入，对于亚马逊，页面加载时间每增加 <em>100ms</em> 就意味着 <em>1%</em> 的销售额损失。</p><p><br></p><p>可见，页面的加载速度对于用户有着至关重要的影响。</p><p><br></p><p>一个好的交互效果可能是这样的：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-16-041314.png\" alt=\"image-20210916121313325\" contenteditable=\"false\"><br></p><p><br></p><p>当然，性能优化是来自方方面面的。</p><p><br></p><p>这里我们主要来看 <em>CSS</em> 方面能够进行哪些性能优化。</p><p><br></p><p>1.使用 <code data-backticks=\"1\">id selector</code> 非常的高效。在使用 <code data-backticks=\"1\">id selector</code> 的时候需要注意一点：因为 <code data-backticks=\"1\">id</code> 是唯一的，所以不需要既指定 <code data-backticks=\"1\">id</code> 又指定 <code data-backticks=\"1\">tagName</code>：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">/* Bad  */\np#id1 {color:red;}  \n\n/* Good  */\n#id1 {color:red;}</code></pre></div><p>2.避免深层次的 <code data-backticks=\"1\">node</code> ，譬如：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">/* Bad  */\ndiv &gt; div &gt; div &gt; p {color:red;} \n/* Good  */\np-class{color:red;}</code></pre></div><p>3.不要使用 <code data-backticks=\"1\">attribute selector</code>，如：p[att1=”val1”]。这样的匹配非常慢。更不要这样写：<code data-backticks=\"1\">p[id=\"id1\"]</code>。这样将 <code data-backticks=\"1\">id selector</code> 退化成 <code data-backticks=\"1\">attribute selector</code>。</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">/* Bad  */\np[id=\"jartto\"]{color:red;}  \np[class=\"blog\"]{color:red;}  \n/* Good  */\n#jartto{color:red;}  \n.blog{color:red;}</code></pre></div><p>4.通常将浏览器前缀置于前面，将标准样式属性置于最后，类似：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">.foo {\n  -moz-border-radius: 5px;\n  border-radius: 5px;\n}</code></pre></div><p>这里推荐参阅 <em>CSS</em> 规范-优化方案：<em>http://nec.netease.com/standard/css-optimize.html</em></p><p><br></p><p>5.遵守 <em>CSSLint</em> 规则</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">font-faces        　　　　  　　　不能使用超过5个web字体\nimport        　　　　　　　 　　  禁止使用@import\nregex-selectors        　　　　  禁止使用属性选择器中的正则表达式选择器\nuniversal-selector    　　 　　  禁止使用通用选择器*\nunqualified-attributes    　　　禁止使用不规范的属性选择器\nzero-units            　　 　　　0后面不要加单位\noverqualified-elements    　　　使用相邻选择器时，不要使用不必要的选择器\nshorthand        　　　　　　　　 简写样式属性\nduplicate-background-images    相同的url在样式表中不超过一次</code></pre></div><p>更多的 <em>CSSLint</em> 规则可以参阅：<em>https://github.com/CSSLint/csslint</em></p><p><br></p><p>6.不要使用 <code data-backticks=\"1\">@import</code></p><p><br></p><p>使用 <code data-backticks=\"1\">@import</code> 引入 <code data-backticks=\"1\">CSS</code> 会影响浏览器的并行下载。使用 <code data-backticks=\"1\">@import</code> 引用的 <code data-backticks=\"1\">CSS</code> 文件只有在引用它的那个 <code data-backticks=\"1\">CSS</code> 文件被下载、解析之后，浏览器才会知道还有另外一个 <code data-backticks=\"1\">CSS</code> 需要下载，这时才去下载，然后下载后开始解析、构建 <code data-backticks=\"1\">Render Tree</code> 等一系列操作。</p><p><br></p><p>多个 <code data-backticks=\"1\">@import</code> 会导致下载顺序紊乱。在 <code data-backticks=\"1\">IE</code> 中，<code data-backticks=\"1\">@import</code> 会引发资源文件的下载顺序被打乱，即排列在 <code data-backticks=\"1\">@import</code> 后面的 <code data-backticks=\"1\">JS</code> 文件先于 <code data-backticks=\"1\">@import</code> 下载，并且打乱甚至破坏 <code data-backticks=\"1\">@import</code> 自身的并行下载。</p><p><br></p><p>7.避免过分重排（<em>Reflow</em>）</p><p>所谓重排就是浏览器重新计算布局位置与大小。常见的重排元素：</p><div data-language=\"css\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"css\">width \nheight \npadding \nmargin \ndisplay \nborder-width \nborder \ntop \nposition \nfont-size \nfloat \ntext-align \noverflow-y \nfont-weight \noverflow \nleft \nfont-family \nline-height \nvertical-align \nright \nclear \nwhite-space \nbottom \nmin-height</code></pre></div><p>8.依赖继承。如果某些属性可以继承，那么自然没有必要在写一遍。</p>', '/static/uploads/ceeb653ely8gzoktbyo2mj208307z3yr16613059951783825.jpg', 44, 0, '1649385008000', 2);
INSERT INTO `blog` VALUES (6, '包装类型', '在 ES 中数据的分类分为 \"基本数据类型\"和\"引用类型\"。', '[]', '<p>在 <em>ES</em> 中，数据的分类分为<strong>基本数据类型</strong>和<strong>引用类型</strong>。</p><p><br></p><p>按照最新 <em>ES</em> 标准定义，基本数据类型（<em>primitive value</em>）包括 <em>undefined、null、boolean、number、symbol、string</em>。</p><p><br></p><p>引用类型包括 <em>Object、Array、Date、RegExp</em> 等。</p><p><br></p><p>基本数据类型和引用类型这两个类型其中一个很明显的区别是，引用类型有自己内置的方法，也可以自定义其他方法用来操作数据，而基本数据类型不能像引用类型那样有自己的内置方法对数据进行更多的操作。</p><p><br></p><p>但基本数据类型真的就不能使用方法吗？对于部分基本类型来说确实是这样的。</p><p><br></p><p>但是有 <em>3</em> 个是 <em>ES</em> 提供了对应的特殊引用类型（包装类型）<em>Boolean、Number、String</em>。</p><p><br></p><p>基本包装类型，和其他引用类型一样，拥有内置的方法可以对数据进行额外操作。如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var str = \'hello\'; // string 基本类型\nvar s2 = str.charAt(0);\nconsole.log(s2); // h</code></pre></div><p>上面的 <em>string</em> 是一个基本类型，但是它却能调用 <em>charAt( )</em> 的方法。</p><p><br></p><p>其主要是因为在执行第二行代码时，后台会自动进行下面的步骤：</p><ol><li><p>自动创建 <em>String</em> 类型的一个实例（和基本类型的值不同，这个实例就是一个基本包装类型的对象）</p></li><li><p>调用实例（对象）上指定的方法</p></li><li><p>销毁这个实例</p></li></ol><p>用代码的方式解释就是如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//我平常写程序的过程：\nvar str = \'hello\'; // string 基本类型\nvar s2 = str.charAt(0); // 在执行到这一句的时候 后台会自动完成以下动作 ：\n(\n    var _str = new String(\'hello\'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象\n    var s2 = _str.charAt(0); // 2 然后这个对象就可以调用包装对象下的方法，并且返回结给 s2.\n    _str = null;  //    3 之后这个临时创建的对象就被销毁了， str =null; \n)\nconsole.log(s2); // h \nconsole.log(str); // hello</code></pre></div><p>基本类型的值虽然没有方法可以调用，但是后台临时创建的包装对象上有内置方法可以让我们调用方法，因此这样我们就可以对字符串、数值、布尔值这三种基本数据类型的数据进行更多操作。</p><p><br></p><p>而什么时候后台会自动创建一个对应的基本包装类型的对象，取决于当前执行的代码是否是为了获取他的值。</p><p><br></p><p>每当读取一个基本类型的值，也就是当我们需要从内存中获取到他的值时（这个访问过程称为读取模式），这时后台就会自动创建一个基本包装类型的对象。例如：</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var test = \'hhh\'\nconsole.log(test) // 读取模式，后台自动创建基本包装类型对象\nvar test2 = test // 赋值给变量 test2，也需要读取 test 的值，同上</code></pre></div><p>基本包装类型的对象和引用类型的对象最大的一个区别是，对象的生存期不同，导致的一个结果就是，基本包装类型无法自定义自己的方法。</p><p><br></p><p>对于引用类型的数据，在执行流离开当前作用域之前都会保存在内存中，而对于自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间，执行完毕就会立即被销毁。</p><p>如下：</p><div data-language=\"javascript\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"javascript\">var str = \'test\'\nstr.test = \'hhh\'\nconsole.log(str.test) //undefined</code></pre></div><p>上面第二行代码给自动创建的 <em>String</em> 实例对象添加了 <em>test</em> 属性，虽然此刻代码执行时他是生效的，但是在这行代码执行完毕后该 <em>String</em> 实例就会立刻被销毁，<em>String</em> 实例的 <em>test</em> 属性也就不存在了。</p><p><br></p><p>当执行第三行代码时，由于是读取模式，又重新创建了新的 <em>String</em> 实例，而这个新创建的 <em>String</em> 实例没有 <em>test</em> 属性，结果也就是 <em>undefined</em>。</p><p><br></p><p>用代码的方式解释就是如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var str = \'hello\';\nstr.number = 10; //假设我想给字符串添加一个属性 number ，后台会有如下步骤\n(\n    var _str = new String(\'hello\'); // 1 找到对应的包装对象类型，然后通过包装对象创建出一个和基本类型值相同的对象\n    _str.number = 10; // 2 通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存\n    _str =null; // 3 这个对象又被销毁\n)\nconsole.log(str.number); // undefined  当执行到这一句的时候，因为基本类型本来没有属性，后台又会重新重复上面的步骤\n(\n   var str = new String(\'hello\');// 1 找到基本包装对象，然后又新开辟一个内存，创建一个值为 hello 对象\n   str.number = undefined;// 2 因为包装对象下面没有 number 这个属性，所以又会重新添加，因为没有值，所以值是未定义;然后弹出结果\n   str =null; // 3 这个对象又被销毁\n)</code></pre></div><p>那么我们怎么才能给基本类型添加方法或者属性呢？</p><p><br></p><p>答案是在基本包装对象的原型下面添加，每个对象都有原型。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//给字符串添加方法  要写到对应的包装对象的原型下才行\nvar str = \'hello\';\nString.prototype.last= fuction(){ \n    return this.charAt(this.length);\n}; \nstr.last(); // 5 执行到这一句，后台依然会偷偷的干这些事\n(\n    var _str = new String(\'hello\');// 找到基本包装对象，new一个和字符串值相同的对象，\n    _str.last();  // 通过这个对象找到了包装对象下的方法并调用 \n    _str =null; //  这个对象被销毁\n)</code></pre></div>', '/static/uploads/ceeb653ely8h2uljzhepnj20hs0gk3z8 (1)16613064747932686.jpg', 63, 0, '1583379008000', 1);
INSERT INTO `blog` VALUES (7, '原型和原型链', '在 Brendan Eich 设计 JavaScript 时，借鉴了 Self 和 Smalltalk 这两门基于原型的语言。', '[]', '<p>之所以选择基于原型的对象系统，是因为 <em>Brendan Eich</em> 一开始就没有打算在 <em>JavaScript</em> 中加入类的概念，因为 <em>JavaScript</em> 的设计初衷就是为非专业的开发人员（例如网页设计者）提供一个方便的工具。由于大部分网页设计者都没有任何的编程背景，所以在设计 <em>JavaScript</em> 时也是尽可能使其简单、易学。</p><p><br></p><p>这因为如此，<em>JavaScript</em> 中的原型以及原型链成为了这门语言最大的一个特点，在面试的时候，面试官也经常会围绕原型和原型链展开提问。</p><p><br></p><p><em>JavaScript</em> 是一门基于原型的语言，<strong>对象的产生是通过原型对象而来的</strong>。</p><p><br></p><p><em>ES5</em> 中提供了 <em>Object.create</em> 方法，可以用来克隆对象。</p><p><br></p><p>示例如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const person = {\n    arms: 2,\n    legs: 2,\n    walk() {\n        console.log(\'walking\');\n    }\n}\nconst zhangsan = Object.create(person);\nconsole.log(zhangsan.arms); // 2\nconsole.log(zhangsan.legs); // 2\nzhangsan.walk(); // walking\nconsole.log(zhangsan.__proto__ === person); // true</code></pre></div><p>在上面的示例中，我们通过 <em>Object.create</em> 方法来对 <em>person</em> 对象进行克隆，克隆出来了一个名为 <em>zhangsan</em> 的对象，所以 <em>person</em> 对象就是 <em>zhangsan</em> 这个对象的原型对象。</p><p><br></p><p><em>person</em> 对象上面的属性和方法，<em>zhangsan</em> 这个对象上面都有。</p><p><br></p><p>通过 __<em>proto</em>__ 属性，我们可以访问到一个对象的原型对象。</p><p><br></p><p>从上面的代码可以看出，当我们打印<code data-backticks=\"1\">zhangsan.__proto__ === person</code>，返回的是 <em>true</em> ，因为对于 <em>zhangsan</em> 这个对象而言，它的原型对象就是 <em>person</em> 这个对象。</p><p><br></p><p>我们在使用 <em>Object.create</em> 方法来克隆对象的时候，还可以传入第 <em>2</em> 个参数，第 <em>2</em> 个参数是一个 <em>JSON</em> 对象，该对象可以书写新对象的<strong>新属性</strong>以及<strong>属性特性</strong>。</p><p><br></p><p>通过这种方式，基于对象创建的新对象，可以继承祖辈对象的属性和方法，这其实就是一个继承的关系，来看一个示例：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const person = {\n    arms: 2,\n    legs: 2,\n    walk() {\n        console.log(\'walking\');\n    }\n}\nconst zhangsan = Object.create(person, {\n    name: {\n        value: \"zhangsan\",\n    },\n    age: {\n        value: 18,\n    },\n    born: {\n        value: \"chengdu\"\n    }\n});\nconst zhangxiaosan = Object.create(zhangsan, {\n    name: {\n        value: \"zhangxiaosan\"\n    },\n    age: {\n        value: 1\n    }\n})\nconsole.log(zhangxiaosan.name); // zhangxiaosan\nconsole.log(zhangxiaosan.age); // 1\nconsole.log(zhangxiaosan.born); // chengdu\nconsole.log(zhangxiaosan.arms); // 2\nconsole.log(zhangxiaosan.legs); // 2\nzhangxiaosan.walk(); // walking\nconsole.log(zhangsan.isPrototypeOf(zhangxiaosan)); // true\nconsole.log(person.isPrototypeOf(zhangxiaosan)); // true</code></pre></div><p>该例中，<em>zhangsan</em> 这个对象是从 <em>person</em> 这个对象克隆而来的，而 <em>zhangxiaosan</em> 这个对象又是从 <em>zhangsan</em> 这个对象克隆而来，以此<strong>形成了一条原型链</strong>。无论是 <em>person</em> 对象，还是 <em>zhangsan</em> 对象上面的属性和方法，<em>zhangxiaosan</em> 这个对象都能继承到。</p><p><br></p><p>来看下面的图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-10-050603.png\" alt=\"image-20210810130602385\" contenteditable=\"false\"><br></p><p><br></p><p>这就是 <em>JavaScript</em> 中最原始的创建对象的方式，一个对象是通过克隆另外一个对象所得到的。就像克隆羊多莉一样，通过克隆可以创造一个一模一样的对象，被克隆的对象是新对象的原型对象。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-08-10-051614.png\" alt=\"image-20210810131613519\" contenteditable=\"false\"><br></p><p><br></p><p>但是，随着 <em>JavaScript</em> 语言的发展，这样创建对象的方式还是太过于麻烦了。开发者还是期望 <em>JavaScript</em> 能够像 <em>Java、C#</em> 等标准面向对象语言一样，通过类来批量的生成对象。于是出现了通过构造函数来模拟类的形式。</p><p><br></p><p>来看下面的例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nconst apple = new Computer(\"苹果\", 12000);\nconsole.log(apple.name); // 苹果\nconsole.log(apple.price); // 12000\napple.showSth(); // 这是一台苹果电脑\n\nconst huawei = new Computer(\"华为\", 7000);\nconsole.log(huawei.name); // 华为\nconsole.log(huawei.price); // 7000\nhuawei.showSth(); // 这是一台华为电脑</code></pre></div><p>在上面的例子中，我们书写了一个 <em>Computer</em> 的函数，我们称之为构造函数，为了区分普通函数和构造函数，一般构造函数的函数名<strong>首字母会大写</strong>。</p><p><br></p><p>区别于普通函数的直接调用，构造函数一般通过配合 <em>new</em> 关键字一起使用，每当我们 <em>new</em> 一次，就会生成一个新的对象，而在构造函数中的 <em>this</em> 就指向这个新生成的对象。</p><p><br></p><p>在上面的例子中，我们 <em>new</em> 了两次，所以生成了两个对象，我们把这两个对象分别存储到 <em>apple</em> 和 <em>huawei</em> 这两个变量里面。</p><p><br></p><p>有一个非常有意思的现象，就是我们在书写 <em>Computer</em> 构造函数的实例方法的时候，并没有将这个方法书写在构造函数里面，而是写在了 <em>Computer.prototype</em> 上面，那么这个 <em>Computer.prototype</em> 是啥呢？</p><p><br></p><p>这个 <em>Computer.prototype</em> 实际上就是 <em>Computer</em> 实例对象的原型对象。要搞清楚这个，看下面的图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-27-063331.png\" alt=\"image-20211027143330933\" contenteditable=\"false\"><br></p><p><br></p><p>这是最重要的一个三角关系，也是我往往要求学生记下来的三角关系。</p><p><br></p><p>通过上图，我们可以得出以下的结论：</p><ul><li><p><em>JavaScript</em> 中每个对象都有一个原型对象。可以通过 __<em>proto</em>__ 属性来访问到对象的原型对象。</p></li><li><p>构造函数的 <em>prototype</em> 属性指向一个对象，这个对象是该构造函数实例化出来的对象的原型对象。</p></li><li><p>原型对象的 <em>constructor</em> 属性也指向其构造函数。</p></li><li><p>实例对象的 <em>constructor</em> 属性是从它的原型对象上面访问到。</p></li></ul><p>实践才是检验真理的唯一标准。接下来我们在代码中来验证一下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nconst apple = new Computer(\"苹果\", 12000);\n\nconsole.log(apple.__proto__ === Computer.prototype); // true\nconsole.log(apple.__proto__.constructor === Computer); // true</code></pre></div><p>在上面的代码中，<em>apple</em> 是从 <em>Computer</em> 这个构造函数中实例化出来的对象，我们通过 __<em>proto</em>__ 来访问到 <em>apple</em> 的原型对象，而这个原型对象和 <em>Computer.prototype</em> 是等价的。另外， 我们也发现 <em>apple</em> 和它原型对象的 <em>constructor</em> 属性都指向 <em>Computer</em> 这个构造函数。</p><p><br></p><p>接下来我们还可以来验证内置的构造函数是不是也是这样的关系，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nconst apple = new Computer(\"苹果\", 12000);\n\nconsole.log(apple.__proto__ === Computer.prototype); // true\nconsole.log(apple.__proto__.constructor === Computer); // true\n\n// 数组的三角关系\nvar arr = [];\nconsole.log(arr.__proto__ === Array.prototype); // true\n\n// 其实所有的构造函数的原型对象都相同\nconsole.log(Computer.__proto__ === Array.__proto__); // true\nconsole.log(Computer.__proto__ === Date.__proto__); // true\nconsole.log(Computer.__proto__ === Number.__proto__);  // true\nconsole.log(Computer.__proto__ === Function.__proto__);  // true\nconsole.log(Computer.__proto__ === Object.__proto__);  // true\nconsole.log(Computer.__proto__); // {}</code></pre></div><p>通过上面的代码，我们发现所有的构造函数，无论是自定义的还是内置的，它们的原型对象都是同一个对象。</p><p><br></p><p>如果你能够把上面的三角关系理清楚，恭喜你，你已经把整个原型和原型链的知识掌握一大部分。</p><p><br></p><p>如果你还想继续往下深究，那么上面的图可以扩展成这样：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-27-064429.png\" alt=\"image-20211027144428458\" contenteditable=\"false\"><br></p><p><br></p><p>在 <em>JavaScript</em> 中，每一个对象，都有一个原型对象。而原型对象上面也有一个自己的原型对象，一层一层向上找，最终会到达 <em>null</em>。</p><p><br></p><p>我们可以在上面代码的基础上，继续进行验证，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function Computer(name, price) {\n    // 属性写在类里面 \n    this.name = name;\n    this.price = price;\n}\n// 方法挂在原型对象上面\nComputer.prototype.showSth = function () {\n    console.log(`这是一台${this.name}电脑`);\n}\n\nvar apple = new Computer(\"苹果\", 12000);\n\nconsole.log(apple.__proto__.__proto__); // [Object: null prototype] {}\nconsole.log(apple.__proto__.__proto__.__proto__); // null\nconsole.log(apple.__proto__.__proto__ === Object.prototype); // true</code></pre></div><p>可以看到，在上面的代码中，我们顺着原型链一层一层往上找，最终到达了 <em>null</em>。</p><p><br></p><p>但是目前来看我们这个图还是不完整，既然构造函数的原型对象也是对象，那么必然该对象也有自己的原型，所以完整的图其实如下：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-27-072845.png\" alt=\"image-20211027152845110\" contenteditable=\"false\"><br></p><p><br></p><p>下面可以简单验证一下，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 自定义构造函数函数\nfunction Computer() {}\n\nconsole.log(Computer.__proto__.__proto__.__proto__); // null\nconsole.log(Computer.__proto__.constructor.__proto__ === Computer.__proto__); // true\nconsole.log(Computer.__proto__.__proto__.constructor.__proto__ === Computer.__proto__); // true</code></pre></div><p>-<em>EOF</em>-</p>', '/static/uploads/006APoFYly8gt9izouwqig309q081kjl16613068615705234.gif', 74, 0, '1618111808000', 1);
INSERT INTO `blog` VALUES (8, '垃圾回收与内存泄漏', '浏览器的 *Javascript* 具有自动垃圾回收机制（*GC*：*Garbage Collecation*），也就是说，执行环境会负责管理代码执行过程中使用的内存。', '[{\"name\":\"什么是内存泄露\",\"anchor\":\"什么是内存泄露\",\"level\":2,\"children\":[]},{\"name\":\"*JavaScript* 中的垃圾回收\",\"anchor\":\"javascript-中的垃圾回收\",\"level\":2,\"children\":[]},{\"name\":\"标记清除\",\"anchor\":\"标记清除\",\"level\":2,\"children\":[]},{\"name\":\"引用计数\",\"anchor\":\"引用计数\",\"level\":2,\"children\":[]}]', '<h2 id=\"什么是内存泄露\">什么是内存泄露</h2><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（<em>runtime</em>）就必须供给内存。</p><p><br></p><p>对于持续运行的服务进程（<em>daemon</em>），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p><br></p><p>也就是说，不再用到的内存，如果没有及时释放，就叫做内存泄漏（<em>memory leak</em>）。</p><h2 id=\"javascript-中的垃圾回收\"><em>JavaScript</em> 中的垃圾回收</h2><p>浏览器的 <em>Javascript</em> 具有自动垃圾回收机制（<em>GC</em>：<em>Garbage Collecation</em>），也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：<strong>垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</strong>。</p><p><br></p><p>但是这个过程不是实时的，因为其开销比较大并且 <em>GC</em> 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><p><br></p><p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。</p><p><br></p><p>下面是一段示例代码：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function fn1() {\n    var obj = {name: \'zhangsan\', age: 10};\n}\nfunction fn2() {\n    var obj = {name:\'zhangsan\', age: 10};\n    return obj;\n}\n\nvar a = fn1();\nvar b = fn2();</code></pre></div><p>在上面的代码中，我们首先声明了两个函数，分别叫做 <em>fn1</em> 和 <em>fn2</em>。</p><p><br></p><p>当 <em>fn1</em> 被调用时，进入 <em>fn1</em> 的环境，会开辟一块内存存放对象 <em>{name: \'zhangsan\', age: 10}</em>。而当调用结束后，出了 <em>fn1</em> 的环境，那么该块内存会被  <em>JavaScript</em> 引擎中的垃圾回收器自动释放；</p><p><br></p><p>在 <em>fn2</em> 被调用的过程中，返回的对象被全局变量 <em>b</em> 所指向，所以该块内存并不会被释放。</p><p><br></p><p>这里问题就出现了：到底哪个变量是没有用的？</p><p><br></p><p>所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。</p><p><br></p><p>用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：<strong>标记清除</strong>和<strong>引用计数</strong>。</p><p><br></p><p>引用计数不太常用，标记清除较为常用。</p><h2 id=\"标记清除\">标记清除</h2><p><em>JavaScript</em> 中最常用的垃圾回收方式就是标记清除。</p><p><br></p><p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。</p><p><br></p><p>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。</p><p><br></p><p>而当变量离开环境时，则将其标记为“离开环境”。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function test(){\n  var a = 10 ; // 被标记 ，进入环境 \n  var b = 20 ; // 被标记 ，进入环境\n}\ntest(); // 执行完毕 之后 a、b 又被标离开环境，被回收。</code></pre></div><p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。</p><p><br></p><p>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</p><p><br></p><p>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p><p><br></p><p>到目前为止，<em>IE9+、Firefox、Opera、Chrome、Safari</em> 的 <em>JS</em> 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p><h2 id=\"引用计数\">引用计数</h2><p>引用计数的含义是跟踪记录每个值被引用的次数。</p><p><br></p><p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 <em>1</em>。如果同一个值又被赋给另一个变量，则该值的引用次数加 <em>1</em>。</p><p><br></p><p>相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 <em>1</em>。当这个值的引用次数变成 <em>0</em> 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><p><br></p><p>这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 <em>0</em> 的值所占用的内存。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function test() {\n    var a = {};	// a 指向对象的引用次数为 1\n    var b = a;	// a 指向对象的引用次数加 1，为 2\n    var c = a;	// a 指向对象的引用次数再加 1，为 3\n    var b = {};	// a 指向对象的引用次数减 1，为 2\n}</code></pre></div><p><em>Netscape Navigator3</em> 是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：<strong>循环引用</strong>。</p><p><br></p><p>循环引用指的是对象 <em>A</em> 中包含一个指向对象B的指针，而对象 <em>B</em> 中也包含一个指向对象 <em>A</em> 的引用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function fn() {\n    var a = {};\n    var b = {};\n    a.pro = b;\n    b.pro = a;\n}\nfn();</code></pre></div><p>以上代码 <em>a</em> 和 <em>b</em> 的引用次数都是 <em>2</em>，<em>fn</em> 执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为 <em>a</em> 和 <em>b</em> 的引用次数不为 <em>0</em>，所以不会被垃圾回收器回收内存，如果 <em>fn</em> 函数被大量调用，就会造成内存泄露。在 <em>IE7</em> 与 <em>IE8</em> 上，内存直线上升。</p><p><br></p><p>-<em>EOF</em>-</p>', '/static/uploads/20190704198276_zbayHI16613069696403274.jpg', 77, 0, '1641007808000', 1);
INSERT INTO `blog` VALUES (9, '递归', '递归调用是一种特殊的调用形式，指的是方法自己调用自己的形式。', '[]', '<p><em>A recursive method is a method that calls itself.</em></p><p><br></p><p>递归调用是一种特殊的调用形式，指的是方法自己调用自己的形式。</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-19-063739.png\" alt=\"image-20211019143738665\" contenteditable=\"false\"><br></p><p><br></p><p>下面是一个递归的示例：</p><div data-language=\"java\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"java\">function neverEnd() {\n    console.log(\"This is the method that never ends!\");\n    neverEnd();\n}</code></pre></div><p><em>method</em> 会先输出 <em>This is the method that never ends!</em> 然后再调用自己，导致无限递归（<em>infinite recursion</em>）。当然这一般是我们需要避免的状况。</p><p><br></p><p>在进行递归操作的时候，我们需要满足以下几个条件：</p><ul><li><p>递归调用必须有结束条件</p></li><li><p>每次调用的时候都需要根据需求改变传递的参数内容</p></li></ul><p>下面是递归的一个示例，求某个数的阶乘。</p><div data-language=\"java\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"java\">function factorial(x) {\n    if (x === 1) {\n        return 1;\n    } else {\n        return x * factorial(x - 1);\n    }\n}\nconsole.log(factorial(5)); // 120</code></pre></div><p>整个递归的计算过程如下：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>===&gt; factorial(5)\n===&gt; 5 * factorial(4)\n===&gt; 5 * (4 * factorial(3))\n===&gt; 5 * (4 * (3 * factorial(2)))\n===&gt; 5 * (4 * (3 * (2 * factorial(1))))\n===&gt; 5 * (4 * (3 * (2 * 1)))\n===&gt; 5 * (4 * (3 * 2))\n===&gt; 5 * (4 * 6)\n===&gt; 5 * 24\n===&gt; 120</code></pre></div><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-19-063535.png\" alt=\"image-20211019143535293\" contenteditable=\"false\"><br></p><p><br></p><p>使用递归时需要注意如下事项：</p><ul><li><p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以用循环的方式来实现。</p></li><li><p>使用递归时需要注意防止栈溢出。在计算机中，函数调用是通过栈（<em>stack</em>）这种数据结构实现的，每当一个函数调用，栈就会加一层，每当函数返回，栈就会减一层。由于栈的大小不是无限的，所以递归调用的次数过多，会导致栈溢出。</p></li></ul><p>下面再来看几个递归的示例：</p><p><br></p><p>示例 <em>1</em>：使用递归来计算从 <em>x</em> 加到 <em>y</em> 的结果</p><div data-language=\"go\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"go\">function calc(i, j) {\n    if (i == j) {\n        return i;\n    }\n    return calc(i, j - 1) + j;\n}\nconsole.log(calc(1, 100)); // 5050</code></pre></div><p>示例 <em>2</em>：使用递归来计算斐波那契数列</p><div data-language=\"go\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"go\">function calc(i) {\n    if (i == 1) {\n        return 1;\n    } else if (i == 2) {\n        return 2;\n    } else {\n        return calc(i - 1) + calc(i - 2);\n    }\n}\nconsole.log(calc(7)); // 21</code></pre></div>', '/static/uploads/ceeb653ely1gabn9o3hgig207109gavf16613071456349183.gif', 21, 0, '1583379008000', 1);
INSERT INTO `blog` VALUES (10, '属性描述符', '属性描述符是 *ECMAScript* 5 新增的语法，它其实就是一个内部对象，用来描述对象的属性的特性。', '[{\"name\":\"属性描述符详解\",\"anchor\":\"属性描述符详解\",\"level\":2,\"children\":[{\"name\":\"属性描述符的结构\",\"anchor\":\"属性描述符的结构\",\"level\":3,\"children\":[]},{\"name\":\"*get* 和 *set* 函数\",\"anchor\":\"get-和-set-函数\",\"level\":3,\"children\":[]},{\"name\":\"操作属性描述符\",\"anchor\":\"操作属性描述符\",\"level\":3,\"children\":[]},{\"name\":\"控制对象状态\",\"anchor\":\"控制对象状态\",\"level\":3,\"children\":[]}]}]', '<h2 id=\"属性描述符详解\">属性描述符详解</h2><p>在 <em>JavaScript</em> 中，对象的属性可以分为两种：</p><ul><li><p>数据属性：它的本质就是一个数据</p></li><li><p>存取器属性：它的本质是一个函数，但是可以将它当作普通属性来使用，当给该属性赋值时，会运行相应的 <em>setter</em> 函数，当获取该属性的值时，会运行相应的 <em>getter</em> 函数。除了存取器，还有一些其他的关键字，用以表示当前属性是否可写、是否有默认值、是否可枚举等，这些关键字就是属性描述符。</p></li></ul><p>属性描述符是 <em>ECMAScript</em> 5 新增的语法，它其实就是一个内部对象，用来描述对象的属性的特性。</p><h3 id=\"属性描述符的结构\">属性描述符的结构</h3><p>在定义对象、定义属性时、属性描述符实际上就是一个对象。</p><p><br></p><p>属性描述符一共有 <em>6</em> 个，可以选择使用。</p><ul><li><p><em>value</em>：设置属性值，默认值为 <em>undefined</em>。</p></li><li><p><em>writable</em>：设置属性值是否可写，默认值为 <em>true</em>。</p></li><li><p><em>enumerable</em>：设置属性是否可枚举，即是否允许使用 <em>for/in</em> 语句或 <em>Object.keys( )</em> 函数遍历访问，默认为 <em>true</em>。</p></li><li><p><em>configurable</em>：设置是否可设置属性特性，默认为 <em>true</em>。如果为 <em>false</em>，将无法删除该属性，不能够修改属性值，也不能修改属性的属性描述符。</p></li><li><p><em>get</em>：取值函数，默认为 <em>undefined</em>。</p></li><li><p><em>set</em>：存值函数，默认为 <em>undefined</em>。</p></li></ul><p>注意这几个属性不是都可以一起设置，具体如下图：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-10-21-031647.png\" alt=\"image-20211021111647398\" contenteditable=\"false\"><br></p><p><br></p><p><strong>示例 1</strong></p><p><br></p><p>下面示例演示了使用 <em>value</em> 读写属性值的基本用法。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};  //定义空对象\nObject.defineProperty(obj, \'x\', {value : 100});  //添加属性x，值为100\nconsole.log(Object.getOwnPropertyDescriptor(obj, \'x\').value);  //返回100</code></pre></div><p><strong>示例 2</strong></p><p><br></p><p>下面示例演示了使用 <em>writable</em> 属性禁止修改属性 <em>x</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};\nObject.defineProperty(obj, \'x\', {\n    value : 1,  //设置属性默认值为1\n    writable : false  //禁止修改属性值\n});\nobj.x = 2;  //修改属性x的值\nconsole.log(obj.x);  // 1 说明修改失败</code></pre></div><p>在正常模式下，如果 <em>writable</em> 为 <em>false</em>，重写属性值不会报错，但是操作失败，而在严格模式下则会抛出异常。</p><p><br></p><p><strong>示例 3</strong></p><p><br></p><p><em>configurable</em> 可以禁止修改属性描述符，当其值为 <em>false</em> 时，<em>value、writable、enumerable</em> 和 <em>configurable</em> 禁止修改，同时禁止删除属性。</p><p><br></p><p>在下面示例中，当设置属性 <em>x</em> 禁止修改配置后，下面操作都是不允许的，其中 <em>obj.x=5;</em> 若操作失败，则后面 <em>4</em> 个操作方法都将抛出异常。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = Object.defineProperty({}, \'x\', {\n    configurable : false  // 禁止配置\n});\nobj.x = 5;  //试图修改其值\nconsole.log(obj.x);  //修改失败，返回undefined\nObject.defineProperty(obj, \'x\', {value : 2});  //抛出异常\nObject.defineProperty(obj, \'x\', {writable: true});  //抛出异常\nObject.defineProperty(obj, \'x\', {enumerable: true});  //抛出异常\nObject.defineProperty(obj, \'x\', {configurable: true});  //抛出异常</code></pre></div><p>当 <em>configurable</em> 为 <em>false</em> 时，如果把 <em>writable=true</em> 改为 <em>false</em> 是允许的。只要 <em>writable</em> 或 <em>configurable</em> 有一个为 <em>true</em>，则 <em>value</em> 也允许修改。</p><h3 id=\"get-和-set-函数\"><em>get</em> 和 <em>set</em> 函数</h3><p>除了使用点语法或中括号语法访问属性的 <em>value</em> 外，还可以使用访问器，包括 <em>set</em> 和 <em>get</em> 两个函数。</p><p><br></p><p>其中，<em>set( )</em> 函数可以设置 <em>value</em> 属性值，而 <em>get( )</em> 函数可以读取 <em>value</em> 属性值。</p><p><br></p><p>借助访问器，可以为属性的 <em>value</em> 设计高级功能，如禁用部分特性、设计访问条件、利用内部变量或属性进行数据处理等。</p><p><br></p><p><strong>示例 1</strong></p><p><br></p><p>下面示例设计对象 <em>obj</em> 的 <em>x</em> 属性值必须为数字。为属性 <em>x</em> 定义了 <em>get</em> 和 <em>set</em> 特性，<em>obj.x</em> 取值时，就会调用 <em>get</em>；赋值时，就会调用 <em>set</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = Object.create(Object.prototype, {\n    _x : {  //数据属性\n        value : 1,  //初始值\n        writable : true\n    },\n    x : {  //访问器属性\n        get : function () {  //getter\n            return this._x;  //返回_x属性值\n        },\n        set : function (value) {  //setter\n            if (typeof value != \"number\"){\n              throw new Error(\'请输入数字\');\n            }\n            this._x = value;  //赋值\n        }\n    }\n});\nconsole.log(obj.x);  //1\nobj.x = \"2\";  //抛出异常</code></pre></div><p><strong>示例 2</strong></p><p><br></p><p><em>JavaScript</em> 也支持一种简写方法。针对示例 <em>1</em>，通过以下方式可以快速定义属性。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {\n    _x : 1,  // 定义 _x 属性\n    get x() { return this._x },  //定义 x 属性的 getter\n    set x(value) {  //定义 x 属性的 setter\n        if (typeof value != \"number\"){\n          throw new Error(\'请输入数字\');\n        }\n        this._x = value;  // 赋值\n    }\n};\nconsole.log(obj.x);  //1\nobj.x = 2;\nconsole.log(obj.x);  //2</code></pre></div><p>取值函数 <em>get( )</em> 不能接收参数，存值函数 <em>set( )</em> 只能接收一个参数，用于设置属性的值。</p><h3 id=\"操作属性描述符\">操作属性描述符</h3><p>属性描述符是一个内部对象，无法直接读写，可以通过下面几个函数进行操作。</p><ul><li><p><em>Object.getOwnPropertyDescriptor( )</em>：可以读出指定对象私有属性的属性描述符。</p></li><li><p><em>Object.defineProperty( )</em>：通过定义属性描述符来定义或修改一个属性，然后返回修改后的描述符。</p></li><li><p><em>Object.defineProperties( )</em>：可以同时定义多个属性描述符。</p></li><li><p><em>Object.getOwnPropertyNames( )</em>：获取对象的所有私有属性。</p></li><li><p><em>Object.keys( )</em>：获取对象的所有本地可枚举的属性。</p></li><li><p><em>propertyIsEnumerable( )</em>：对象实例方法，直接调用，判断指定的属性是否可枚举。</p></li></ul><p><strong>示例 1</strong></p><p><br></p><p>在下面示例中，定义 <em>obj</em> 的 <em>x</em> 属性允许配置特性，然后使用 <em>Object.getOwnPropertyDescriptor( )</em> 函数获取对象 <em>obj</em> 的 <em>x</em> 属性的属性描述符。修改属性描述符的 <em>set</em> 函数，重设检测条件，允许非数值型数字赋值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = Object.create(Object.prototype, {\n    _x: {  //数据属性\n        value: 1,  //初始值\n        writable: true\n    },\n    x: {  //访问器属性\n        configurable: true,  //允许修改配置\n        get: function () {  //getter\n            return this._x;  //返回_x属性值\n        },\n        set: function (value) {\n            if (typeof value != \"number\") {\n                throw new Error(\'请输入数字\');\n            }\n            this._x = value;  //赋值\n        }\n    }\n});\nvar des = Object.getOwnPropertyDescriptor(obj, \"x\");  //获取属性x的属性描述符\ndes.set = function (value) {\n    //修改属性x的属性描述符set函数\n    //允许非数值型的数字，也可以进行赋值\n    if (typeof value != \"number\" &amp;&amp; isNaN(value * 1)) {\n        throw new Error(\'请输入数字\');\n    }\n    this._x = value;\n}\nobj = Object.defineProperty(obj, \"x\", des);\nconsole.log(obj.x);  //1\nobj.x = \"2\";  //把一个给数值型数字赋值给属性x\nconsole.log(obj.x);  //2</code></pre></div><p><strong>示例 2</strong></p><p><br></p><p>下面示例先定义一个扩展函数，使用它可以把一个对象包含的属性以及丰富的信息复制给另一个对象。</p><p><br></p><p>【实现代码】</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">function extend (toObj, fromObj) {  //扩展对象\n    for (var property in fromObj) {  //遍历对象属性\n        if (!fromObj.hasOwnProperty(property)) continue;  //过滤掉继承属性\n        Object.defineProperty(  //复制完整的属性信息\n            toObj,  //目标对象\n            property,  //私有属性\n            Object.getOwnPropertyDescriptor(fromObj, property)  //获取属性描述符\n        );\n    }\n    return toObj;  //返回目标对象\n}</code></pre></div><p>【应用代码】</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj = {};  //新建对象\nobj.x = 1;  //定义对象属性\nextend(obj, { get y() { return 2} })  //定义读取器对象\nconsole.log(obj.y);  //2</code></pre></div><h3 id=\"控制对象状态\">控制对象状态</h3><p><em>JavaScript</em> 提供了 <em>3</em> 种方法，用来精确控制一个对象的读写状态，防止对象被改变。</p><ul><li><p><em>Object.preventExtensions</em>：阻止为对象添加新的属性。</p></li><li><p><em>Object.seal</em>：阻止为对象添加新的属性，同时也无法删除旧属性。等价于属性描述符的 <em>configurable</em> 属性设为 <em>false</em>。注意，该方法不影响修改某个属性的值。</p></li><li><p><em>Object.freeze</em>：阻止为一个对象添加新属性、删除旧属性、修改属性值。</p></li></ul><p>同时提供了 <em>3</em> 个对应的辅助检查函数，简单说明如下：</p><ul><li><p><em>Object.isExtensible</em>：检查一个对象是否允许添加新的属性。</p></li><li><p><em>Object.isSealed</em>：检查一个对象是否使用了 <em>Object.seal</em> 方法。</p></li><li><p><em>Object.isFrozen</em>：检查一个对象是否使用了 <em>Object.freeze</em> 方法。</p></li></ul><p><strong>示例</strong></p><p><br></p><p>下面代码分别使用 <em>Object.preventExtensions、Object.seal</em> 和 <em>Object.freeze</em> 函数控制对象的状态，然后再使用 <em>Object.isExtensible、Object.isSealed</em> 和 <em>Object.isFrozen</em> 函数检测对象的状态。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var obj1 = {};\nconsole.log(Object.isExtensible(obj1));  //true\nObject.preventExtensions(obj1);\nconsole.log(Object.isExtensible(obj1));  //false\nvar obj2 = {};\nconsole.log(Object.isSealed(obj2));  //true\nObject.seal(obj2);\nconsole.log(Object.isSealed(obj2));  //false\nvar obj3 = {};\nconsole.log(Object.isFrozen(obj3));  //true\nObject.freeze(obj3);\nconsole.log(Object.isFrozen(obj3));  //false</code></pre></div>', '/static/uploads/006szvLFgy1fwll8fpyzdj30b407dq5d (1)16613074182633059.jpg', 123, 0, '1620185408000', 1);
INSERT INTO `blog` VALUES (11, 'WeakSet和 WeakMap', '首先我从大家都熟悉的对象开始说起...', '[{\"name\":\"从对象开始说起\",\"anchor\":\"从对象开始说起\",\"level\":2,\"children\":[]},{\"name\":\"*Map*\",\"anchor\":\"map\",\"level\":2,\"children\":[{\"name\":\"添加属性\",\"anchor\":\"添加属性\",\"level\":3,\"children\":[]},{\"name\":\"获取属性和长度\",\"anchor\":\"获取属性和长度\",\"level\":3,\"children\":[]},{\"name\":\"遍历 *Map* 对象\",\"anchor\":\"遍历-map-对象\",\"level\":3,\"children\":[]},{\"name\":\"删除属性\",\"anchor\":\"删除属性\",\"level\":3,\"children\":[]},{\"name\":\"*Map* 和 *Object* 的区别\",\"anchor\":\"map-和-object-的区别\",\"level\":3,\"children\":[]}]},{\"name\":\"*WeakMap*\",\"anchor\":\"weakmap\",\"level\":2,\"children\":[]},{\"name\":\"*Set*\",\"anchor\":\"set\",\"level\":2,\"children\":[{\"name\":\"添加属性\",\"anchor\":\"添加属性-1\",\"level\":3,\"children\":[]},{\"name\":\"遍历对象\",\"anchor\":\"遍历对象\",\"level\":3,\"children\":[]},{\"name\":\"删除属性\",\"anchor\":\"删除属性-1\",\"level\":3,\"children\":[]},{\"name\":\"应用场景\",\"anchor\":\"应用场景\",\"level\":3,\"children\":[]}]},{\"name\":\"*WeakSet*\",\"anchor\":\"weakset\",\"level\":2,\"children\":[]},{\"name\":\"比较总结\",\"anchor\":\"比较总结\",\"level\":2,\"children\":[]}]', '<h2 id=\"从对象开始说起\">从对象开始说起</h2><p>首先我从大家都熟悉的对象开始说起。</p><p><br></p><p>对于对象的使用，大家其实是非常熟悉的，所以我这里仅简单的过一遍。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const algorithm = { site: \"leetcode\" };\nconsole.log(algorithm.site); // leetcode\n\nfor (const key in algorithm) {\n  console.log(key, algorithm[key]);\n}\n\n// site leetcode\ndelete algorithm.site;\nconsole.log(algorithm.site); // undefined</code></pre></div><p>在上面的代码中，有一个 <em>algorithm</em> 对象，它的 <em>key</em> 和 <em>value</em> 是一个字符串类型的值，之后通过点（ . ）进行值的访问。</p><p><br></p><p>另外，<em>for-in</em> 循环也很适合在对象中循环。可以使用中括号（ [ ] ）访问其键对应的值。但是不能使用 <em>for-of</em> 循环，因为对象是不可迭代的。</p><p><br></p><p>对象的属性可以用 <em>delete</em> 关键字来删除。</p><p><br></p><p>好的，我们已经快速讨论了有关对象的一些事项：</p><ul><li><p>如何添加属性</p></li><li><p>如何遍历对象</p></li><li><p>如何删除属性</p></li></ul><p>关于对象的讨论暂时就到这儿。</p><h2 id=\"map\"><em>Map</em></h2><p><em>Map</em> 是 <em>JavaScript</em> 中新的集合对象，其功能类似于对象。但是，与常规对象相比，存在一些主要差异。</p><p><br></p><p>首先，看一个创建 <em>Map</em> 对象的简单示例。</p><h3 id=\"添加属性\">添加属性</h3><p>首先，通过 <em>Map</em> 构造函数，我们可以创建一个 <em>Map</em> 实例对象出来，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\n// Map(0) {}</code></pre></div><p><em>Map</em> 有一种特殊的方法可在其中添加称为 <em>set</em> 的属性。它有两个参数：键是第一个参数，值是第二个参数。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.set(\'name\', \'john\');\n// Map(1) {\"name\" =&gt; \"john\"}</code></pre></div><p>但是，它不允许你在其中添加现有数据。如果 <em>Map</em> 对象中已经存在与新数据的键对应的值，则不会添加新数据。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.set(\'phone\', \'iPhone\');\n// Map(2) {\"name\" =&gt; \"john\", \"phone\" =&gt; \"iPhone\"}\nmap.set(\'phone\', \'iPhone\');\n// Map(2) {\"name\" =&gt; \"john\", \"phone\" =&gt; \"iPhone\"}</code></pre></div><p>但是可以用其他值覆盖现有数据。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.set(\'phone\', \'Galaxy\');\n// Map(2) {\"name\" =&gt; \"john\", \"phone\" =&gt; \"Galaxy\"}</code></pre></div><p>二维数组和 <em>Map</em> 对象之间可以很方便的相互转换。例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">var arr = [\n    [1, 2],\n    [3, 4],\n    [5, 6],\n];\n\nvar map = new Map(arr);\nconsole.log(map); //Map { 1 =&gt; 2, 3 =&gt; 4, 5 =&gt; 6 }\nconsole.log(Array.from(map)); //[ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]</code></pre></div><h3 id=\"获取属性和长度\">获取属性和长度</h3><p>可以通过 <em>get</em> 方法或者 <em>Map</em> 对象某一条属性的值：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set(\'name\', \'john\');\nmap.set(\'phone\', \'iPhone\');\nconsole.log(map.get(\'phone\')); // iPhone</code></pre></div><p>可以通过 <em>has</em> 方法来查询是否具有某一条属性：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set(\'name\', \'john\');\nmap.set(\'phone\', \'iPhone\');\nconsole.log(map.has(\'phone\')); // true</code></pre></div><p>可以通过 <em>size</em> 属性获取 <em>Map</em> 对象的长度：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set(\'name\', \'john\');\nmap.set(\'phone\', \'iPhone\');\nconsole.log(map.size); // 2</code></pre></div><h3 id=\"遍历-map-对象\">遍历 <em>Map</em> 对象</h3><p><em>Map</em> 是一个可迭代的对象，这意味着可以使用 <em>for-of</em> 语句将其映射。</p><p><br></p><p><em>Map</em> 以数组形式提供数据，要获取键或值则需要解构数组或以索引的方式来进行访问。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (const item of map) {\n  console.dir(item);\n}\n// Array(2) [\"name\", \"john\"]\n// Array(2) [\"phone\", \"Galaxy\"]</code></pre></div><p>要仅获取键或值，还有一些方法可供使用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.keys();\n// MapIterator {\"name\", \"phone\"}\nmap.values();\n// MapIterator {\"john\", \"Galaxy\"}\nmap.entries();\n// MapIterator {\"name\" =&gt; \"john\", \"phone\" =&gt; \"Galaxy\"}</code></pre></div><p>也可以使用 <em>forEach</em> 方法，例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set(\'name\', \'john\');\nmap.set(\'phone\', \'iPhone\');\nmap.forEach(item=&gt;{\n    console.log(item);\n})\n// john\n// iPhone</code></pre></div><p>可以使用展开操作符(  ...  )来获取 <em>Map</em> 的全部数据，因为展开操作符还可以在幕后与可迭代对象一起工作。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const simpleSpreadedMap = [...map];\n// [Array(2), Array(2)]</code></pre></div><h3 id=\"删除属性\">删除属性</h3><p>从 <em>Map</em> 对象中删除数据也很容易，你所需要做的就是调用 <em>delete</em>。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">map.delete(\'phone\');\n// true\nmap.delete(\'fake\');\n// false</code></pre></div><p><em>delete</em> 返回布尔值，该布尔值指示 <em>delete</em> 函数是否成功删除了数据。如果是，则返回 <em>true</em>，否则返回 <em>false</em>。</p><p><br></p><p>如果要清空整个 <em>Map</em> 对象，可以使用 <em>clear</em> 方法，如下：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const map = new Map();\nmap.set(\'name\', \'john\');\nmap.set(\'phone\', \'iPhone\');\nconsole.log(map); // Map(2) { \'name\' =&gt; \'john\', \'phone\' =&gt; \'iPhone\' }\nmap.clear();\nconsole.log(map); // Map(0) {}</code></pre></div><h3 id=\"map-和-object-的区别\"><em>Map</em> 和 <em>Object</em> 的区别</h3><p>关于 <em>Map</em> 和 <em>Object</em> 的区别，可以参阅下表：</p><p><br></p><p><img src=\"https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-30-103632.png\" alt=\"image-20210930183632548\" contenteditable=\"false\"><br></p><h2 id=\"weakmap\"><em>WeakMap</em></h2><p><em>WeakMap</em> 起源于 <em>Map</em>，因此它们彼此非常相似。但是，<em>WeakMap</em> 具有很大的不同。</p><p><br></p><p><em>WeakMap</em> 的名字是怎么来的呢？</p><p><br></p><p>嗯，是因为它与它的引用链接所指向的数据对象的连接或关系没有 <em>Map</em> 的连接或关系那么强，所以它是弱的。</p><p><br></p><p>那么，这到底是什么意思呢？</p><p><br></p><p><strong>差异 <em>1</em>：<em>key</em> 必须是对象</strong></p><p><br></p><p>可以将任何值作为键传入 <em>Map</em> 对象，但 <em>WeakMap</em> 不同，它只接受一个对象作为键，否则，它将返回一个错误。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const John = { name: \'John\' };\nconst weakMap = new WeakMap();\nweakMap.set(John, \'student\');\n// WeakMap {{...} =&gt; \"student\"}\nweakMap.set(\'john\', \'student\');\n// Uncaught TypeError: Invalid value used as weak map key</code></pre></div><p><strong>差异 <em>2</em>：并非 <em>Map</em> 中的所有方法都支持</strong></p><p><br></p><p><em>WeakMap</em> 可以使用的方法如下：</p><ul><li><p><em>delete</em></p></li><li><p><em>get</em></p></li><li><p><em>has</em></p></li><li><p><em>set</em></p></li></ul><p>还有一个最大的不同是 <em>WeakMap</em> 不支持迭代对象的方法。</p><p><br></p><p><strong>差异 <em>3</em>：当 <em>GC</em> 清理引用时，数据会被删除</strong></p><p><br></p><p>这是和 <em>Map</em> 相比最大的不同。</p><p><br></p><p>例如：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let John = { major: \"math\" };\n\nconst map = new Map();\nconst weakMap = new WeakMap();\n\nmap.set(John, \'John\');\nweakMap.set(John, \'John\');\n\nJohn = null;\n/* John 被垃圾收集 */</code></pre></div><p>当 <em>John</em> 对象被垃圾回收时，<em>Map</em> 对象将保持引用链接，而 <em>WeakMap</em> 对象将丢失链接。</p><p><br></p><p>所以当你使用 <em>WeakMap</em> 时，你应该考虑这个特点。</p><h2 id=\"set\"><em>Set</em></h2><p><em>Set</em> 也非常类似于 <em>Map</em>，但是 <em>Set</em> 对于单个值更有用。</p><h3 id=\"添加属性-1\">添加属性</h3><p>使用 <em>add</em> 方法可以添加属性。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">const set = new Set();\n\nset.add(1);\nset.add(\'john\');\nset.add(BigInt(10));\n// Set(4) {1, \"john\", 10n}</code></pre></div><p>与 <em>Map</em> 一样，<em>Set</em> 也不允许添加相同的值。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">set.add(5);\n// Set(1) {5}\n\nset.add(5);\n// Set(1) {5}</code></pre></div><p>对于原始数据类型（<em>boolean、number、string、null、undefined</em>），如果储存相同值则只保存一个，对于引用类型,引用地址完全相同则只会存一个。</p><ul><li><p><em>+0</em> 与 <em>-0</em> 在存储判断唯一性的时候是恒等的，所以不可以重复。</p></li><li><p><em>undefined</em> 和 <em>undefined</em> 是恒等的，所以不可以重复。</p></li><li><p><em>NaN</em> 与 <em>NaN</em> 是不恒等的，但是在 <em>Set</em> 中只能存一个不能重复。</p></li></ul><h3 id=\"遍历对象\">遍历对象</h3><p>由于 <em>Set</em> 是一个可迭代的对象，因此可以使用 <em>for-of</em> 或 <em>forEach</em> 语句。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">for (const val of set) {\n  console.dir(val);\n}\n// 1\n// \'John\'\n// 10n\n// 5\n\nset.forEach(val =&gt; console.dir(val));\n// 1\n// \'John\'\n// 10n\n// 5</code></pre></div><h3 id=\"删除属性-1\">删除属性</h3><p>这一部分和 <em>Map</em> 的删除完全一样。如果数据被成功删除，它返回 <em>true</em>，否则返回 <em>false</em>。</p><p><br></p><p>当然也可以使用 clear 方法清空 <em>Set</em> 集合。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">set.delete(5); \n// true\nset.delete(function(){});\n// false;\n\nset.clear();</code></pre></div><p>如果你不想将相同的值添加到数组表单中，则 <em>Set</em> 可能会非常有用。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">/* With Set */\nconst set = new Set();\nset.add(1);\nset.add(2);\nset.add(2);\nset.add(3);\nset.add(3);\n// Set {1, 2, 3}\n\n// Converting to Array\nconst arr = [ ...set ];\n// [1, 2, 3]\n\nObject.prototype.toString.call(arr);\n// [object Array]\n\n/* Without Set */\nconst hasSameVal = val =&gt; ar.some(v === val);\nconst ar = [];\n\nif (!hasSameVal(1)) ar.push(1);\nif (!hasSameVal(2)) ar.push(2);\nif (!hasSameVal(3)) ar.push(3);</code></pre></div><h3 id=\"应用场景\">应用场景</h3><p>接下来来看一下 <em>Set</em> 常见的应用场景：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">//数组去重\n...new Set([1,1,2,2,3])\n\n//并集\nvar arr1 = [1, 2, 3]\nvar arr2 = [2, 3, 4]\nvar newArr = [...new Set([...arr1, ...arr2])]\n//交集\nvar arr1 = [1, 2, 3]\nvar arr2 = [2, 3, 4]\nvar set1 = new Set(arr1)\nvar set2 = new Set(arr2)\nvar newArr = []\nset1.forEach(item =&gt; {\n    set2.has(item) ? newArr.push(item) : \'\'\n})\nconsole.log(newArr)\n//差集\nvar arr1 = [1, 2, 3]\nvar arr2 = [2, 3, 4]\nvar set1 = new Set(arr1)\nvar set2 = new Set(arr2)\nvar newArr = []\nset1.forEach(item =&gt; {\n    set2.has(item) ? \'\' : newArr.push(item)\n})\nset2.forEach(item =&gt; {\n    set1.has(item) ? \'\' : newArr.push(item)\n})\nconsole.log(newArr)</code></pre></div><h2 id=\"weakset\"><em>WeakSet</em></h2><p><em>WeakSet</em> 和 <em>Set</em> 区别如下：</p><ul><li><p><em>WeakSet</em> 只能储存对象引用，不能存放值，而 <em>Set</em> 对象都可以</p></li><li><p><em>WeakSet</em> 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 <em>WeakSet</em> 对该对象的引用，如果没有其他的变量或者属性引用这个对象值，则这个对象将会被垃圾回收掉。（不考虑该对象还存在与 <em>WeakSet</em> 中），所以 <em>WeakSet</em> 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到，被垃圾回收了。因此 <em>ES6</em> 规定，<em>WeakSet</em> 对象是无法被遍历的，也没有办法拿到它包含的所有元素。</p></li></ul><p><em>WeakSet</em> 能够使用的方法如下：</p><ul><li><p><em>add(value)</em> 方法：在 <em>WeakSet</em> 中添加一个元素。如果添加的元素已存在，则不会进行操作。</p></li><li><p><em>delete(value)</em> 方法：删除元素 <em>value</em></p></li><li><p><em>has(value)</em> 方法：判断 <em>WeakSet</em> 对象中是否包含 <em>value</em></p></li><li><p><em>clear( )</em> 方法：清空所有元素</p></li></ul><p>下面来看一下 <em>WeakSet</em> 的代码示例，与 <em>WeakMap</em> 一样，<em>WeakSet</em> 也将丢失对内部数据的访问链接（如果内部数据已被垃圾收集）。</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">let John = { major: \"math\" };\n\nconst set = new Set();\nconst weakSet = new WeakSet();\n\nset.add(John);\n// Set {{...}}\nweakSet.add(John);\n// WeakSet {{...}}\n\nJohn = null;\n/* John 被垃圾收集 */</code></pre></div><p>一旦对象 <em>John</em> 被垃圾回收，<em>WeakSet</em> 就无法访问其引用 <em>John</em> 的数据。而且 <em>WeakSet</em> 不支持 <em>for-of</em> 或 <em>forEach</em>，因为它不可迭代。</p><h2 id=\"比较总结\">比较总结</h2><ul><li><p><em>Map</em></p><ul><li><p>键名唯一不可重复</p></li><li><p>类似于集合，键值对的集合，任何值都可以作为一个键或者一个值</p></li><li><p>可以遍历，可以转换各种数据格式，方法 <em>get、set、has、delete</em></p></li></ul></li><li><p><em>WeakMap</em></p><ul><li><p>只接受对象为键名，不接受其他类型的值作为键名，键值可以是任意</p></li><li><p>键名是拖引用，键名所指向的对象，会被垃圾回收机制回收</p></li><li><p>不能遍历，方法 <em>get、set、has、delete</em></p></li></ul></li><li><p><em>Set</em></p><ul><li><p>成员唯一，无序且不会重复</p></li><li><p>类似于数组集合，键值和键名是一致的（只有键值。没有键名）</p></li><li><p>可以遍历，方法有 <em>add、delete、has</em></p></li></ul></li><li><p><em>WeakSet</em></p><ul><li><p>只能存储对应引用，不能存放值</p></li><li><p>成员都是弱引用，会被垃圾回收机制回收</p></li><li><p>不能遍历，方法有 <em>add、delete、has</em></p></li></ul></li></ul><p>-<em>EOF</em>-</p>', '/static/uploads/006m97Kgly1fwq1v50u6jj30k00k0ac416613079285073388.jpg', 9, 1, '1657942208000', 1);
INSERT INTO `blog` VALUES (12, 'Node 事件循环', '我们经常说 *JavaScript* 是一门单线程语言，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？', '[{\"name\":\"*Node.js* 与浏览器的事件循环有何区别？\",\"anchor\":\"nodejs-与浏览器的事件循环有何区别\",\"level\":2,\"children\":[{\"name\":\"进程与线程\",\"anchor\":\"进程与线程\",\"level\":3,\"children\":[]},{\"name\":\"浏览器内核\",\"anchor\":\"浏览器内核\",\"level\":3,\"children\":[{\"name\":\"*GUI* 渲染线程\",\"anchor\":\"gui-渲染线程\",\"level\":4,\"children\":[]},{\"name\":\"*JavaScript* 引擎线程\",\"anchor\":\"javascript-引擎线程\",\"level\":4,\"children\":[]},{\"name\":\"定时触发器线程\",\"anchor\":\"定时触发器线程\",\"level\":4,\"children\":[]},{\"name\":\"事件触发线程\",\"anchor\":\"事件触发线程\",\"level\":4,\"children\":[]},{\"name\":\"异步 *http* 请求线程\",\"anchor\":\"异步-http-请求线程\",\"level\":4,\"children\":[]}]},{\"name\":\"浏览器中的事件循环\",\"anchor\":\"浏览器中的事件循环\",\"level\":3,\"children\":[{\"name\":\"宏任务和微任务\",\"anchor\":\"宏任务和微任务\",\"level\":4,\"children\":[]},{\"name\":\"事件循环流程\",\"anchor\":\"事件循环流程\",\"level\":4,\"children\":[]}]},{\"name\":\"*Node.js* 中的事件循环\",\"anchor\":\"nodejs-中的事件循环\",\"level\":3,\"children\":[{\"name\":\"*Node.js* 事件循环介绍\",\"anchor\":\"nodejs-事件循环介绍\",\"level\":4,\"children\":[]},{\"name\":\"事件循环的 *6* 个阶段\",\"anchor\":\"事件循环的-6-个阶段\",\"level\":4,\"children\":[]},{\"name\":\"一些注意点\",\"anchor\":\"一些注意点\",\"level\":4,\"children\":[]},{\"name\":\"*Node.js* 与浏览器的事件队列的差异\",\"anchor\":\"nodejs-与浏览器的事件队列的差异\",\"level\":4,\"children\":[]}]}]}]', '<p>我们经常说 <em>JavaScript</em> 是一门单线程语言，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p>', '/static/uploads/006APoFYly8h3dwg3geoeg306o06oha9 (1)16613087810049622.gif', 92, 0, '1644809408000', 1);
INSERT INTO `blog` VALUES (13, '组件间通信', '该文章总结了vue组件间常见的几种通信方式', '[{\"name\":\"父子组件通信\",\"anchor\":\"父子组件通信\",\"level\":1,\"children\":[{\"name\":\"`prop`\",\"anchor\":\"prop\",\"level\":2,\"children\":[]},{\"name\":\"`event`\",\"anchor\":\"event\",\"level\":2,\"children\":[]},{\"name\":\"`style`和`class`\",\"anchor\":\"style和class\",\"level\":2,\"children\":[]},{\"name\":\"`attribute`\",\"anchor\":\"attribute\",\"level\":2,\"children\":[]},{\"name\":\"`natvie`修饰符\",\"anchor\":\"natvie修饰符\",\"level\":2,\"children\":[]},{\"name\":\"`$listeners`\",\"anchor\":\"listeners\",\"level\":2,\"children\":[]},{\"name\":\"`v-model`\",\"anchor\":\"v-model\",\"level\":2,\"children\":[]},{\"name\":\"`sync`修饰符\",\"anchor\":\"sync修饰符\",\"level\":2,\"children\":[]},{\"name\":\"`$parent`和`$children`\",\"anchor\":\"parent和children\",\"level\":2,\"children\":[]},{\"name\":\"`$slots`和`$scopedSlots`\",\"anchor\":\"slots和scopedslots\",\"level\":2,\"children\":[]},{\"name\":\"`ref`\",\"anchor\":\"ref\",\"level\":2,\"children\":[]}]},{\"name\":\"跨组件通信\",\"anchor\":\"跨组件通信\",\"level\":1,\"children\":[{\"name\":\"`Provide`和`Inject`\",\"anchor\":\"provide和inject\",\"level\":2,\"children\":[]},{\"name\":\"`router`\",\"anchor\":\"router\",\"level\":2,\"children\":[]},{\"name\":\"`vuex`\",\"anchor\":\"vuex\",\"level\":2,\"children\":[]},{\"name\":\"`store`模式\",\"anchor\":\"store模式\",\"level\":2,\"children\":[]},{\"name\":\"`eventbus`\",\"anchor\":\"eventbus\",\"level\":2,\"children\":[]}]}]', '<h1 id=\"父子组件通信\">父子组件通信</h1><blockquote><p>绝大部分<code data-backticks=\"1\">vue</code>本身提供的通信方式，都是父子组件通信</p></blockquote><h2 id=\"prop\"><code data-backticks=\"1\">prop</code></h2><p>最常见的组件通信方式之一，由父组件传递到子组件</p><h2 id=\"event\"><code data-backticks=\"1\">event</code></h2><p>最常见的组件通信方式之一，当子组件发生了某些事，可以通过<code data-backticks=\"1\">event</code>通知父组件</p><h2 id=\"style和class\"><code data-backticks=\"1\">style</code>和<code data-backticks=\"1\">class</code></h2><p>父组件可以向子组件传递<code data-backticks=\"1\">style</code>和<code data-backticks=\"1\">class</code>，它们会合并到子组件的根元素中</p><p><br></p><p><strong>示例</strong></p><p><br></p><p>父组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div id=\"app\"&gt;\n    &lt;HelloWorld\n      style=\"color:red\"\n      class=\"hello\"\n      msg=\"Welcome to Your Vue.js App\"\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport HelloWorld from \"./components/HelloWorld.vue\";\n\nexport default {\n  components: {\n    HelloWorld,\n  },\n};\n&lt;/script&gt;</code></pre></div><p>子组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div class=\"world\" style=\"text-align:center\"&gt;\n    &lt;h1&gt;{{msg}}&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: \"HelloWorld\",\n  props: {\n    msg: String,\n  },\n};\n&lt;/script&gt;</code></pre></div><p>渲染结果：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;div class=\"hello world\" style=\"color:red; text-aling:center\"&gt;\n    &lt;h1&gt;Welcome to Your Vue.js App&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div><h2 id=\"attribute\"><code data-backticks=\"1\">attribute</code></h2><p>如果父组件传递了一些属性到子组件，但子组件并没有声明这些属性，则它们称之为<code data-backticks=\"1\">attribute</code>，这些属性会直接附着在子组件的根元素上</p><blockquote><p>不包括<code data-backticks=\"1\">style</code>和<code data-backticks=\"1\">class</code>，它们会被特殊处理</p></blockquote><p><strong>示例</strong></p><p><br></p><p>父组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div id=\"app\"&gt;\n    &lt;!-- 除 msg 外，其他均为 attribute --&gt;\n    &lt;HelloWorld\n      data-a=\"1\"\n      data-b=\"2\"\n      msg=\"Welcome to Your Vue.js App\"\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport HelloWorld from \"./components/HelloWorld.vue\";\n\nexport default {\n  components: {\n    HelloWorld,\n  },\n};\n&lt;/script&gt;</code></pre></div><p>子组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;{{msg}}&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: \"HelloWorld\",\n  props: {\n    msg: String,\n  },\n  created() {\n    console.log(this.$attrs); // 得到： { \"data-a\": \"1\", \"data-b\": \"2\" }\n  },\n};\n&lt;/script&gt;</code></pre></div><p>渲染结果：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;div data-a=\"1\" data-b=\"2\"&gt;\n    &lt;h1&gt;Welcome to Your Vue.js App&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div><p>子组件可以通过<code data-backticks=\"1\">inheritAttrs: false</code>配置，禁止将<code data-backticks=\"1\">attribute</code>附着在子组件的根元素上，但不影响通过<code data-backticks=\"1\">$attrs</code>获取</p><h2 id=\"natvie修饰符\"><code data-backticks=\"1\">natvie</code>修饰符</h2><p>在注册事件时，父组件可以使用<code data-backticks=\"1\">native</code>修饰符，将事件注册到子组件的根元素上</p><p><br></p><p><strong>示例</strong></p><p><br></p><p>父组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div id=\"app\"&gt;\n    &lt;HelloWorld @click.native=\"handleClick\" /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport HelloWorld from \"./components/HelloWorld.vue\";\n\nexport default {\n  components: {\n    HelloWorld,\n  },\n  methods: {\n    handleClick() {\n      console.log(1);\n    },\n  },\n};\n&lt;/script&gt;</code></pre></div><p>子组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Hello World&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre></div><p>渲染结果</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;div id=\"app\"&gt;\n  &lt;!-- 点击该 div，会输出 1 --&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Hello World&lt;/h1&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div><h2 id=\"listeners\"><code data-backticks=\"1\">$listeners</code></h2><p>子组件可以通过<code data-backticks=\"1\">$listeners</code>获取父组件传递过来的所有事件处理函数</p><h2 id=\"v-model\"><code data-backticks=\"1\">v-model</code></h2><p>后续章节讲解</p><h2 id=\"sync修饰符\"><code data-backticks=\"1\">sync</code>修饰符</h2><p>和<code data-backticks=\"1\">v-model</code>的作用类似，用于双向绑定，不同点在于<code data-backticks=\"1\">v-model</code>只能针对一个数据进行双向绑定，而<code data-backticks=\"1\">sync</code>修饰符没有限制</p><p><br></p><p>示例</p><p><br></p><p>子组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;\n      &lt;button @click=\"$emit(`update:num1`, num1 - 1)\"&gt;-&lt;/button&gt;\n      {{ num1 }}\n      &lt;button @click=\"$emit(`update:num1`, num1 + 1)\"&gt;+&lt;/button&gt;\n    &lt;/p&gt;\n    &lt;p&gt;\n      &lt;button @click=\"$emit(`update:num2`, num2 - 1)\"&gt;-&lt;/button&gt;\n      {{ num2 }}\n      &lt;button @click=\"$emit(`update:num2`, num2 + 1)\"&gt;+&lt;/button&gt;\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: [\"num1\", \"num2\"],\n};\n&lt;/script&gt;</code></pre></div><p>父组件</p><div data-language=\"vue\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"vue\">&lt;template&gt;\n  &lt;div id=\"app\"&gt;\n    &lt;Numbers :num1.sync=\"n1\" :num2.sync=\"n2\" /&gt;\n    &lt;!-- 等同于 --&gt;\n    &lt;Numbers\n      :num1=\"n1\"\n      @update:num1=\"n1 = $event\"\n      :num2=\"n2\"\n      @update:num2=\"n2 = $event\"\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport Numbers from \"./components/Numbers.vue\";\n\nexport default {\n  components: {\n    Numbers,\n  },\n  data() {\n    return {\n      n1: 0,\n      n2: 0,\n    };\n  },\n};\n&lt;/script&gt;</code></pre></div><h2 id=\"parent和children\"><code data-backticks=\"1\">$parent</code>和<code data-backticks=\"1\">$children</code></h2><p>在组件内部，可以通过<code data-backticks=\"1\">$parent</code>和<code data-backticks=\"1\">$children</code>属性，分别得到当前组件的父组件和子组件实例</p><h2 id=\"slots和scopedslots\"><code data-backticks=\"1\">$slots</code>和<code data-backticks=\"1\">$scopedSlots</code></h2><p>后续章节讲解</p><h2 id=\"ref\"><code data-backticks=\"1\">ref</code></h2><p>父组件可以通过<code data-backticks=\"1\">ref</code>获取到子组件的实例</p><h1 id=\"跨组件通信\">跨组件通信</h1><h2 id=\"provide和inject\"><code data-backticks=\"1\">Provide</code>和<code data-backticks=\"1\">Inject</code></h2><p>示例</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 父级组件提供 \'foo\'\nvar Provider = {\n  provide: {\n    foo: \'bar\'\n  },\n  // ...\n}\n\n// 组件注入 \'foo\'\nvar Child = {\n  inject: [\'foo\'],\n  created () {\n    console.log(this.foo) // =&gt; \"bar\"\n  }\n  // ...\n}</code></pre></div><p>详见：https://cn.vuejs.org/v2/api/?#provide-inject</p><h2 id=\"router\"><code data-backticks=\"1\">router</code></h2><p>如果一个组件改变了地址栏，所有监听地址栏的组件都会做出相应反应</p><p><br></p><p>最常见的场景就是通过点击<code data-backticks=\"1\">router-link</code>组件改变了地址，<code data-backticks=\"1\">router-view</code>组件就渲染其他内容</p><h2 id=\"vuex\"><code data-backticks=\"1\">vuex</code></h2><p>适用于大型项目的数据仓库</p><h2 id=\"store模式\"><code data-backticks=\"1\">store</code>模式</h2><p>适用于中小型项目的数据仓库</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// store.js\nconst store = {\n  loginUser: ...,\n  setting: ...\n}\n\n// compA\nconst compA = {\n  data(){\n    return {\n      loginUser: store.loginUser\n    }\n  }\n}\n\n// compB\nconst compB = {\n  data(){\n    return {\n      setting: store.setting,\n      loginUser: store.loginUser\n    }\n  }\n}</code></pre></div><h2 id=\"eventbus\"><code data-backticks=\"1\">eventbus</code></h2><p>组件通知事件总线发生了某件事，事件总线通知其他监听该事件的所有组件运行某个函数</p>', '/static/uploads/006ARE9vgy1fu1dxkth55j30c80c83z116613094826437821.jpg', 95, 0, '1597116608000', 4);
INSERT INTO `blog` VALUES (14, '虚拟dom', '虚拟dom本质上就是一个普通的JS对象，用于描述视图的界面结构', '[{\"name\":\"什么是虚拟dom？\",\"anchor\":\"什么是虚拟dom\",\"level\":2,\"children\":[]},{\"name\":\"为什么需要虚拟dom？\",\"anchor\":\"为什么需要虚拟dom\",\"level\":2,\"children\":[]},{\"name\":\"虚拟dom是如何转换为真实dom的？\",\"anchor\":\"虚拟dom是如何转换为真实dom的\",\"level\":2,\"children\":[]},{\"name\":\"模板和虚拟dom的关系\",\"anchor\":\"模板和虚拟dom的关系\",\"level\":2,\"children\":[]}]', '<h2 id=\"什么是虚拟dom\">什么是虚拟dom？</h2><p>虚拟dom本质上就是一个普通的JS对象，用于描述视图的界面结构</p><p><br></p><p>在vue中，每个组件都有一个<code data-backticks=\"1\">render</code>函数，每个<code data-backticks=\"1\">render</code>函数都会返回一个虚拟dom树，这也就意味着每个组件都对应一棵虚拟DOM树</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/20210225140726.png\" alt=\"image-20210225140726003\" contenteditable=\"false\"><br></p><h2 id=\"为什么需要虚拟dom\">为什么需要虚拟dom？</h2><p>在<code data-backticks=\"1\">vue</code>中，渲染视图会调用<code data-backticks=\"1\">render</code>函数，这种渲染不仅发生在组件创建时，同时发生在视图依赖的数据更新时。如果在渲染时，直接使用真实<code data-backticks=\"1\">DOM</code>，由于真实<code data-backticks=\"1\">DOM</code>的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。</p><p><br></p><p>因此，<code data-backticks=\"1\">vue</code>在渲染时，使用虚拟dom来替代真实dom，主要为解决渲染效率的问题。</p><h2 id=\"虚拟dom是如何转换为真实dom的\">虚拟dom是如何转换为真实dom的？</h2><p>在一个组件实例首次被渲染时，它先生成虚拟dom树，然后根据虚拟dom树创建真实dom，并把真实dom挂载到页面中合适的位置，此时，每个虚拟dom便会对应一个真实的dom。</p><p><br></p><p>如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用render函数，创建出一个新的虚拟dom树，用新树和旧树对比，通过对比，vue会找到最小更新量，然后更新必要的虚拟dom节点，最后，这些更新过的虚拟节点，会去修改它们对应的真实dom</p><p><br></p><p>这样一来，就保证了对真实dom达到最小的改动。</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/20210225144108.png\" alt=\"image-20210225144108143\" contenteditable=\"false\"><br></p><h2 id=\"模板和虚拟dom的关系\">模板和虚拟dom的关系</h2><p>vue框架中有一个<code data-backticks=\"1\">compile</code>模块，它主要负责将模板转换为<code data-backticks=\"1\">render</code>函数，而<code data-backticks=\"1\">render</code>函数调用后将得到虚拟dom。</p><p><br></p><p>编译的过程分两步：</p><ol><li><p>将模板字符串转换成为<code data-backticks=\"1\">AST</code></p></li><li><p>将<code data-backticks=\"1\">AST</code>转换为<code data-backticks=\"1\">render</code>函数</p></li></ol><p>如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译。</p><p><br></p><p>如果是在<code data-backticks=\"1\">vue-cli</code>的默认配置下，编译发生在打包时，这称之为模板预编译。</p><p><br></p><p>编译是一个极其耗费性能的操作，预编译可以有效的提高运行时的性能，而且，由于运行的时候已不需要编译，<code data-backticks=\"1\">vue-cli</code>在打包时会排除掉<code data-backticks=\"1\">vue</code>中的<code data-backticks=\"1\">compile</code>模块，以减少打包体积</p><p><br></p><p>模板的存在，仅仅是为了让开发人员更加方便的书写界面代码</p><p><br></p><p><strong>vue最终运行的时候，最终需要的是render函数，而不是模板，因此，模板中的各种语法，在虚拟dom中都是不存在的，它们都会变成虚拟dom的配置</strong></p>', '/static/uploads/2022_0805_08da7863g00rg4kxb02rdd2006q00bxg00it00xc16613096987367068.gif', 51, 0, '1646364608000', 4);
INSERT INTO `blog` VALUES (15, 'vue2响应式原理', '**响应式数据的最终目标**，是当对象本身或对象属性发生变化时，将会运行一些函数，最常见的就是render函数。', '[{\"name\":\"Observer\",\"anchor\":\"observer\",\"level\":1,\"children\":[]},{\"name\":\"Dep\",\"anchor\":\"dep\",\"level\":1,\"children\":[]},{\"name\":\"Watcher\",\"anchor\":\"watcher\",\"level\":1,\"children\":[]},{\"name\":\"Scheduler\",\"anchor\":\"scheduler\",\"level\":1,\"children\":[]},{\"name\":\"总体流程\",\"anchor\":\"总体流程\",\"level\":1,\"children\":[]}]', '<blockquote><p>vue官方阐述：https://cn.vuejs.org/v2/guide/reactivity.html</p></blockquote><p><strong>响应式数据的最终目标</strong>，是当对象本身或对象属性发生变化时，将会运行一些函数，最常见的就是render函数。</p><p><br></p><p>在具体实现上，vue用到了<strong>几个核心部件</strong>：</p><ol><li><p>Observer</p></li><li><p>Dep</p></li><li><p>Watcher</p></li><li><p>Scheduler</p></li></ol><h1 id=\"observer\">Observer</h1><p>Observer要实现的目标非常简单，就是把一个普通的对象转换为响应式的对象</p><p><br></p><p>为了实现这一点，Observer把对象的每个属性通过<code data-backticks=\"1\">Object.defineProperty</code>转换为带有<code data-backticks=\"1\">getter</code>和<code data-backticks=\"1\">setter</code>的属性，这样一来，当访问或设置属性时，<code data-backticks=\"1\">vue</code>就有机会做一些别的事情。</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/20210226153448.png\" alt=\"image-20210226153448807\" contenteditable=\"false\"><br></p><p><br></p><p>Observer是vue内部的构造器，我们可以通过Vue提供的静态方法<code data-backticks=\"1\">Vue.observable( object )</code>间接的使用该功能。</p><p><br></p><p>在组件生命周期中，这件事发生在<code data-backticks=\"1\">beforeCreate</code>之后，<code data-backticks=\"1\">created</code>之前。</p><p><br></p><p>具体实现上，它会递归遍历对象的所有属性，以完成深度的属性转换。</p><p><br></p><p>由于遍历时只能遍历到对象的当前属性，因此无法监测到将来动态增加或删除的属性，因此<code data-backticks=\"1\">vue</code>提供了<code data-backticks=\"1\">$set</code>和<code data-backticks=\"1\">$delete</code>两个实例方法，让开发者通过这两个实例方法对已有响应式对象添加或删除属性。</p><p><br></p><p>对于数组，<code data-backticks=\"1\">vue</code>会更改它的隐式原型，之所以这样做，是因为vue需要监听那些可能改变数组内容的方法</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/20210226154624.png\" alt=\"image-20210226154624015\" contenteditable=\"false\"><br></p><p><br></p><p>总之，Observer的目标，就是要让一个对象，它属性的读取、赋值，内部数组的变化都要能够被vue感知到。</p><h1 id=\"dep\">Dep</h1><p>这里有两个问题没解决，就是读取属性时要做什么事，而属性变化时要做什么事，这个问题需要依靠Dep来解决。</p><p><br></p><p>Dep的含义是<code data-backticks=\"1\">Dependency</code>，表示依赖的意思。</p><p><br></p><p><code data-backticks=\"1\">Vue</code>会为响应式对象中的每个属性、对象本身、数组本身创建一个<code data-backticks=\"1\">Dep</code>实例，每个<code data-backticks=\"1\">Dep</code>实例都有能力做以下两件事：</p><ul><li><p>记录依赖：是谁在用我</p></li><li><p>派发更新：我变了，我要通知那些用到我的人</p></li></ul><p>当读取响应式对象的某个属性时，它会进行依赖收集：有人用到了我</p><p><br></p><p>当改变某个属性时，它会派发更新：那些用我的人听好了，我变了</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/20210226155852.png\" alt=\"image-20210226155852964\" contenteditable=\"false\"><br></p><h1 id=\"watcher\">Watcher</h1><p>这里又出现一个问题，就是Dep如何知道是谁在用我？</p><p><br></p><p>要解决这个问题，需要依靠另一个东西，就是Watcher。</p><p><br></p><p>当某个函数执行的过程中，用到了响应式数据，响应式数据是无法知道是哪个函数在用自己的</p><p><br></p><p>因此，vue通过一种巧妙的办法来解决这个问题</p><p><br></p><p>我们不要直接执行函数，而是把函数交给一个叫做watcher的东西去执行，watcher是一个对象，每个这样的函数执行时都应该创建一个watcher，通过watcher去执行</p><p><br></p><p>watcher会设置一个全局变量，让全局变量记录当前负责执行的watcher等于自己，然后再去执行函数，在函数的执行过程中，如果发生了依赖记录<code data-backticks=\"1\">dep.depend()</code>，那么<code data-backticks=\"1\">Dep</code>就会把这个全局变量记录下来，表示：有一个watcher用到了我这个属性</p><p><br></p><p>当Dep进行派发更新时，它会通知之前记录的所有watcher：我变了</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/20210226161404.png\" alt=\"image-20210226161404327\" contenteditable=\"false\"><br></p><p><br></p><p>每一个<code data-backticks=\"1\">vue</code>组件实例，都至少对应一个<code data-backticks=\"1\">watcher</code>，该<code data-backticks=\"1\">watcher</code>中记录了该组件的<code data-backticks=\"1\">render</code>函数。</p><p><br></p><p><code data-backticks=\"1\">watcher</code>首先会把<code data-backticks=\"1\">render</code>函数运行一次以收集依赖，于是那些在render中用到的响应式数据就会记录这个watcher。</p><p><br></p><p>当数据变化时，dep就会通知该watcher，而watcher将重新运行render函数，从而让界面重新渲染同时重新记录当前的依赖。</p><h1 id=\"scheduler\">Scheduler</h1><p>现在还剩下最后一个问题，就是Dep通知watcher之后，如果watcher执行重运行对应的函数，就有可能导致函数频繁运行，从而导致效率低下</p><p><br></p><p>试想，如果一个交给watcher的函数，它里面用到了属性a、b、c、d，那么a、b、c、d属性都会记录依赖，于是下面的代码将触发4次更新：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">state.a = \"new data\";\nstate.b = \"new data\";\nstate.c = \"new data\";\nstate.d = \"new data\";</code></pre></div><p>这样显然是不合适的，因此，watcher收到派发更新的通知后，实际上不是立即执行对应函数，而是把自己交给一个叫调度器的东西</p><p><br></p><p>调度器维护一个执行队列，该队列同一个watcher仅会存在一次，队列中的watcher不是立即执行，它会通过一个叫做<code data-backticks=\"1\">nextTick</code>的工具方法，把这些需要执行的watcher放入到事件循环的微队列中，nextTick的具体做法是通过<code data-backticks=\"1\">Promise</code>完成的</p><blockquote><p>nextTick 通过 <code data-backticks=\"1\">this.$nextTick</code> 暴露给开发者</p><p><br></p><p>nextTick 的具体处理方式见：https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97</p></blockquote><p>也就是说，当响应式数据变化时，<code data-backticks=\"1\">render</code>函数的执行是异步的，并且在微队列中</p><h1 id=\"总体流程\">总体流程</h1><p><img src=\"http://mdrs.yuanjin.tech/img/20210226163936.png\" alt=\"image-20210226163936839\" contenteditable=\"false\"><br></p>', '/static/uploads/9e31678cgy1fu1hiqscv5j20c80c8dg016613098877581830.jpg', 82, 0, '1650511808000', 4);
INSERT INTO `blog` VALUES (16, 'vue2生命周期', '有关vue2生命周期各各阶段发生的了什么,以及数据改变后vue2里面做了哪些操作,通过此文章你将得到答案', '[{\"name\":\"创建vue实例和创建组件的流程基本一致\",\"anchor\":\"创建vue实例和创建组件的流程基本一致\",\"level\":2,\"children\":[]},{\"name\":\"重渲染？\",\"anchor\":\"重渲染\",\"level\":2,\"children\":[]}]', '<blockquote><p><code data-backticks=\"1\">new Vue</code>之后，发生了什么？数据改变后，又发生了什么？</p></blockquote><p><img src=\"http://mdrs.yuanjin.tech/img/20210302155735.png\" alt=\"image-20210302155735758\" contenteditable=\"false\"><br></p><h2 id=\"创建vue实例和创建组件的流程基本一致\">创建vue实例和创建组件的流程基本一致</h2><ol><li><p>首先做一些初始化的操作，主要是设置一些私有属性到实例中</p></li><li><p><strong>运行生命周期钩子函数<code data-backticks=\"1\">beforeCreate</code></strong></p></li><li><p>进入注入流程：处理属性、computed、methods、data、provide、inject，最后使用代理模式将它们挂载到实例中</p></li><li><p><strong>运行生命周期钩子函数<code data-backticks=\"1\">created</code></strong></p></li><li><p>生成<code data-backticks=\"1\">render</code>函数：如果有配置，直接使用配置的<code data-backticks=\"1\">render</code>，如果没有，使用运行时编译器，把模板编译为<code data-backticks=\"1\">render</code></p></li><li><p><strong>运行生命周期钩子函数<code data-backticks=\"1\">beforeMount</code></strong></p></li><li><p>创建一个<code data-backticks=\"1\">Watcher</code>，传入一个函数<code data-backticks=\"1\">updateComponent</code>，该函数会运行<code data-backticks=\"1\">render</code>，把得到的<code data-backticks=\"1\">vnode</code>再传入<code data-backticks=\"1\">_update</code>函数执行。</p><p><br></p><p>在执行<code data-backticks=\"1\">render</code>函数的过程中，会收集所有依赖，将来依赖变化时会重新运行<code data-backticks=\"1\">updateComponent</code>函数</p><p><br></p><p>在执行<code data-backticks=\"1\">_update</code>函数的过程中，触发<code data-backticks=\"1\">patch</code>函数，由于目前没有旧树，因此直接为当前的虚拟dom树的每一个普通节点生成elm属性，即真实dom。</p><p><br></p><p>如果遇到创建一个组件的vnode，则会进入组件实例化流程，该流程和创建vue实例流程基本相同，最终会把创建好的组件实例挂载vnode的<code data-backticks=\"1\">componentInstance</code>属性中，以便复用。</p></li><li><p><strong>运行生命周期钩子函数<code data-backticks=\"1\">mounted</code></strong></p></li></ol><h2 id=\"重渲染\">重渲染？</h2><ol><li><p>数据变化后，所有依赖该数据的<code data-backticks=\"1\">Watcher</code>均会重新运行，这里仅考虑<code data-backticks=\"1\">updateComponent</code>函数对应的<code data-backticks=\"1\">Watcher</code></p></li><li><p><code data-backticks=\"1\">Watcher</code>会被调度器放到<code data-backticks=\"1\">nextTick</code>中运行，也就是微队列中，这样是为了避免多个依赖的数据同时改变后被多次执行</p></li><li><p><strong>运行生命周期钩子函数<code data-backticks=\"1\">beforeUpdate</code></strong></p></li><li><p><code data-backticks=\"1\">updateComponent</code>函数重新执行</p><p><br></p><p>在执行<code data-backticks=\"1\">render</code>函数的过程中，会去掉之前的依赖，重新收集所有依赖，将来依赖变化时会重新运行<code data-backticks=\"1\">updateComponent</code>函数</p><p><br></p><p>在执行<code data-backticks=\"1\">_update</code>函数的过程中，触发<code data-backticks=\"1\">patch</code>函数。</p><p><br></p><p>新旧两棵树进行对比。</p><p><br></p><p>普通<code data-backticks=\"1\">html</code>节点的对比会导致真实节点被创建、删除、移动、更新</p><p><br></p><p>组件节点的对比会导致组件被创建、删除、移动、更新</p><p><br></p><p>当新组件需要创建时，进入实例化流程</p><p><br></p><p>当旧组件需要删除时，会调用旧组件的<code data-backticks=\"1\">$destroy</code>方法删除组件，该方法会先触发<strong>生命周期钩子函数<code data-backticks=\"1\">beforeDestroy</code></strong>，然后递归调用子组件的<code data-backticks=\"1\">$destroy</code>方法，然后触发<strong>生命周期钩子函数<code data-backticks=\"1\">destroyed</code></strong></p><p><br></p><p>当组件属性更新时，相当于组件的<code data-backticks=\"1\">updateComponent</code>函数被重新触发执行，进入重渲染流程，和本节相同。</p></li><li><p><strong>运行生命周期钩子函数<code data-backticks=\"1\">updated</code></strong></p></li></ol><p>​</p>', '/static/uploads/006m97Kgly1gjiczds5ksj30ku0ryn2l16613103183673134.jpg', 28, 0, '1653276608000', 4);
INSERT INTO `blog` VALUES (17, 'cookie原理详解', 'cookie是浏览器中特有的一个概念，它就像浏览器的专属卡包，管理着各个网站的身份信息。', '[{\"name\":\"一个不大不小的问题\",\"anchor\":\"一个不大不小的问题\",\"level\":1,\"children\":[]},{\"name\":\"cookie的组成\",\"anchor\":\"cookie的组成\",\"level\":1,\"children\":[]},{\"name\":\"如何设置cookie\",\"anchor\":\"如何设置cookie\",\"level\":1,\"children\":[{\"name\":\"服务器端设置cookie\",\"anchor\":\"服务器端设置cookie\",\"level\":2,\"children\":[]},{\"name\":\"客户端设置cookie\",\"anchor\":\"客户端设置cookie\",\"level\":2,\"children\":[]}]},{\"name\":\"总结\",\"anchor\":\"总结\",\"level\":1,\"children\":[]}]', '<h1 id=\"一个不大不小的问题\">一个不大不小的问题</h1><p>假设服务器有一个接口，通过请求这个接口，可以添加一个管理员</p><p><br></p><p>但是，不是任何人都有权力做这种操作的</p><p><br></p><p>那么服务器如何知道请求接口的人是有权力的呢？</p><p><br></p><p>答案是：只有登录过的管理员才能做这种操作</p><p><br></p><p>可问题是，客户端和服务器的传输使用的是http协议，http协议是无状态的，什么叫无状态，就是<strong>服务器不知道这一次请求的人，跟之前登录请求成功的人是不是同一个人</strong></p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/image-20200417161014030.png\" contenteditable=\"false\"><br></p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/image-20200417161244373.png\" contenteditable=\"false\"><br></p><p><br></p><p>由于http协议的无状态，服务器<strong>忘记</strong>了之前的所有请求，它无法确定这一次请求的客户端，就是之前登录成功的那个客户端。</p><blockquote><p>你可以把服务器想象成有着严重脸盲症的东哥，他没有办法分清楚跟他说话的人之前做过什么</p></blockquote><p>于是，服务器想了一个办法</p><p><br></p><p>它按照下面的流程来认证客户端的身份</p><ol><li><p>客户端登录成功后，服务器会给客户端一个出入证（令牌 token）</p></li><li><p>后续客户端的每次请求，都必须要附带这个出入证（令牌 token）</p></li></ol><p><img src=\"http://mdrs.yuanjin.tech/img/image-20200417161950450.png\" contenteditable=\"false\"><br></p><p><br></p><p>服务器发扬了认证不认人的优良传统，就可以很轻松的识别身份了。</p><p><br></p><p>但是，用户不可能只在一个网站登录，于是客户端会收到来自各个网站的出入证，因此，就要求客户端要有一个类似于卡包的东西，能够具备下面的功能：</p><ol><li><p><strong>能够存放多个出入证</strong>。这些出入证来自不同的网站，也可能是一个网站有多个出入证，分别用于出入不同的地方</p></li><li><p><strong>能够自动出示出入证</strong>。客户端在访问不同的网站时，能够自动的把对应的出入证附带请求发送出去。</p></li><li><p><strong>正确的出示出入证</strong>。客户端不能将肯德基的出入证发送给麦当劳。</p></li><li><p><strong>管理出入证的有效期</strong>。客户端要能够自动的发现那些已经过期的出入证，并把它从卡包内移除。</p></li></ol><p>能够满足上面所有要求的，就是cookie</p><p><br></p><p>cookie类似于一个卡包，专门用于存放各种出入证，并有着一套机制来自动管理这些证件。</p><p><br></p><p>卡包内的每一张卡片，称之为<strong>一个cookie</strong>。</p><h1 id=\"cookie的组成\">cookie的组成</h1><p>cookie是浏览器中特有的一个概念，它就像浏览器的专属卡包，管理着各个网站的身份信息。</p><p><br></p><p>每个cookie就相当于是属于某个网站的一个卡片，它记录了下面的信息：</p><ul><li><p>key：键，比如「身份编号」</p></li><li><p>value：值，比如袁小进的身份编号「14563D1550F2F76D69ECBF4DD54ABC95」，这有点像卡片的条形码，当然，它可以是任何信息</p></li><li><p>domain：域，表达这个cookie是属于哪个网站的，比如<code data-backticks=\"1\">yuanjin.tech</code>，表示这个cookie是属于<code data-backticks=\"1\">yuanjin.tech</code>这个网站的</p></li><li><p>path：路径，表达这个cookie是属于该网站的哪个基路径的，就好比是同一家公司不同部门会颁发不同的出入证。比如<code data-backticks=\"1\">/news</code>，表示这个cookie属于<code data-backticks=\"1\">/news</code>这个路径的。（后续详细解释）</p></li><li><p>secure：是否使用安全传输（后续详细解释）</p></li><li><p>expire：过期时间，表示该cookie在什么时候过期</p></li></ul><p>当浏览器向服务器发送一个请求的时候，它会瞄一眼自己的卡包，看看哪些卡片适合附带捎给服务器</p><p><br></p><p>如果一个cookie<strong>同时满足</strong>以下条件，则这个cookie会被附带到请求中</p><ul><li><p>cookie没有过期</p></li><li><p>cookie中的域和这次请求的域是匹配的</p><ul><li><p>比如cookie中的域是<code data-backticks=\"1\">yuanjin.tech</code>，则可以匹配的请求域是<code data-backticks=\"1\">yuanjin.tech</code>、<code data-backticks=\"1\">www.yuanjin.tech</code>、<code data-backticks=\"1\">blogs.yuanjin.tech</code>等等</p></li><li><p>比如cookie中的域是<code data-backticks=\"1\">www.yuanjin.tech</code>，则只能匹配<code data-backticks=\"1\">www.yuanjin.tech</code>这样的请求域</p></li><li><p>cookie是不在乎端口的，只要域匹配即可</p></li></ul></li><li><p>cookie中的path和这次请求的path是匹配的</p><ul><li><p>比如cookie中的path是<code data-backticks=\"1\">/news</code>，则可以匹配的请求路径可以是<code data-backticks=\"1\">/news</code>、<code data-backticks=\"1\">/news/detail</code>、<code data-backticks=\"1\">/news/a/b/c</code>等等，但不能匹配<code data-backticks=\"1\">/blogs</code></p></li><li><p>如果cookie的path是<code data-backticks=\"1\">/</code>，可以想象，能够匹配所有的路径</p></li></ul></li><li><p>验证cookie的安全传输</p><ul><li><p>如果cookie的secure属性是true，则请求协议必须是<code data-backticks=\"1\">https</code>，否则不会发送该cookie</p></li><li><p>如果cookie的secure属性是false，则请求协议可以是<code data-backticks=\"1\">http</code>，也可以是<code data-backticks=\"1\">https</code></p></li></ul></li></ul><p>如果一个cookie满足了上述的所有条件，则浏览器会把它自动加入到这次请求中</p><p><br></p><p>具体加入的方式是，<strong>浏览器会将符合条件的cookie，自动放置到请求头中</strong>，例如，当我在浏览器中访问百度的时候，它在请求头中附带了下面的cookie：</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/image-20200417170328584.png\" contenteditable=\"false\"><br></p><p><br></p><p>看到打马赛克的地方了吗？这部分就是通过请求头<code data-backticks=\"1\">cookie</code>发送到服务器的，它的格式是<code data-backticks=\"1\">键=值; 键=值; 键=值; ...</code>，每一个键值对就是一个符合条件的cookie。</p><p><br></p><p>**cookie中包含了重要的身份信息，永远不要把你的cookie泄露给别人！！！**否则，他人就拿到了你的证件，有了证件，就具备了为所欲为的可能性。</p><h1 id=\"如何设置cookie\">如何设置cookie</h1><p>由于cookie是保存在浏览器端的，同时，很多证件又是服务器颁发的</p><p><br></p><p>所以，cookie的设置有两种模式：</p><ul><li><p>服务器响应：这种模式是非常普遍的，当服务器决定给客户端颁发一个证件时，它会在响应的消息中包含cookie，浏览器会自动的把cookie保存到卡包中</p></li><li><p>客户端自行设置：这种模式少见一些，不过也有可能会发生，比如用户关闭了某个广告，并选择了「以后不要再弹出」，此时就可以把这种小信息直接通过浏览器的JS代码保存到cookie中。后续请求服务器时，服务器会看到客户端不想要再次弹出广告的cookie，于是就不会再发送广告过来了。</p></li></ul><h2 id=\"服务器端设置cookie\">服务器端设置cookie</h2><p>服务器可以通过设置响应头，来告诉浏览器应该如何设置cookie</p><p><br></p><p>响应头按照下面的格式设置：</p><div data-language=\"yaml\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"yaml\">set-cookie: cookie1\nset-cookie: cookie2\nset-cookie: cookie3\n...</code></pre></div><p>通过这种模式，就可以在一次响应中设置多个cookie了，具体设置多少个cookie，设置什么cookie，根据你的需要自行处理</p><p><br></p><p>其中，每个cookie的格式如下：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>键=值; path=?; domain=?; expire=?; max-age=?; secure; httponly</code></pre></div><p>每个cookie除了键值对是必须要设置的，其他的属性都是可选的，并且顺序不限</p><p><br></p><p>当这样的响应头到达客户端后，<strong>浏览器会自动的将cookie保存到卡包中，如果卡包中已经存在一模一样的卡片（其他key、path、domain相同），则会自动的覆盖之前的设置</strong>。</p><p><br></p><p>下面，依次说明每个属性值：</p><ul><li><p><strong>path</strong>：设置cookie的路径。如果不设置，浏览器会将其自动设置为当前请求的路径。比如，浏览器请求的地址是<code data-backticks=\"1\">/login</code>，服务器响应了一个<code data-backticks=\"1\">set-cookie: a=1</code>，浏览器会将该cookie的path设置为请求的路径<code data-backticks=\"1\">/login</code></p></li><li><p><strong>domain</strong>：设置cookie的域。如果不设置，浏览器会自动将其设置为当前的请求域，比如，浏览器请求的地址是<code data-backticks=\"1\">http://www.yuanjin.tech</code>，服务器响应了一个<code data-backticks=\"1\">set-cookie: a=1</code>，浏览器会将该cookie的domain设置为请求的域<code data-backticks=\"1\">www.yuanjin.tech</code></p><ul><li><p>这里值得注意的是，如果服务器响应了一个无效的域，浏览器是不认的</p></li><li><p>什么是无效的域？就是响应的域连根域都不一样。比如，浏览器请求的域是<code data-backticks=\"1\">yuanjin.tech</code>，服务器响应的cookie是<code data-backticks=\"1\">set-cookie: a=1; domain=baidu.com</code>，这样的域浏览器是不认的。</p></li><li><p>如果浏览器连这样的情况都允许，就意味着张三的服务器，有权利给用户一个cookie，用于访问李四的服务器，这会造成很多安全性的问题</p></li></ul></li><li><p><strong>expire</strong>：设置cookie的过期时间。这里必须是一个有效的GMT时间，即格林威治标准时间字符串，比如<code data-backticks=\"1\">Fri, 17 Apr 2020 09:35:59 GMT</code>，表示格林威治时间的<code data-backticks=\"1\">2020-04-17 09:35:59</code>，即北京时间的<code data-backticks=\"1\">2020-04-17 17:35:59</code>。当客户端的时间达到这个时间点后，会自动销毁该cookie。</p></li><li><p><strong>max-age</strong>：设置cookie的相对有效期。expire和max-age通常仅设置一个即可。比如设置<code data-backticks=\"1\">max-age</code>为<code data-backticks=\"1\">1000</code>，浏览器在添加cookie时，会自动设置它的<code data-backticks=\"1\">expire</code>为当前时间加上1000秒，作为过期时间。</p><ul><li><p>如果不设置expire，又没有设置max-age，则表示会话结束后过期。</p></li><li><p>对于大部分浏览器而言，关闭所有浏览器窗口意味着会话结束。</p></li></ul></li><li><p><strong>secure</strong>：设置cookie是否是安全连接。如果设置了该值，则表示该cookie后续只能随着<code data-backticks=\"1\">https</code>请求发送。如果不设置，则表示该cookie会随着所有请求发送。</p></li><li><p><strong>httponly</strong>：设置cookie是否仅能用于传输。如果设置了该值，表示该cookie仅能用于传输，而不允许在客户端通过JS获取，这对防止跨站脚本攻击（XSS）会很有用。</p><ul><li><p>关于如何通过JS获取，后续会讲解</p></li><li><p>关于什么是XSS，不在本文讨论范围</p></li></ul></li></ul><p>下面来一个例子，客户端通过<code data-backticks=\"1\">post</code>请求服务器<code data-backticks=\"1\">http://yuanjin.tech/login</code>，并在消息体中给予了账号和密码，服务器验证登录成功后，在响应头中加入了以下内容：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>set-cookie: token=123456; path=/; max-age=3600; httponly</code></pre></div><p>当该响应到达浏览器后，浏览器会创建下面的cookie：</p><div data-language=\"yaml\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"yaml\">key: token\nvalue: 123456\ndomain: yuanjin.tech\npath: /\nexpire: 2020-04-17 18:55:00 #假设当前时间是2020-04-17 17:55:00\nsecure: false  #任何请求都可以附带这个cookie，只要满足其他要求\nhttponly: true #不允许JS获取该cookie</code></pre></div><p>于是，随着浏览器后续对服务器的请求，只要满足要求，这个cookie就会被附带到请求头中传给服务器：</p><div data-language=\"yaml\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"yaml\">cookie: token=123456; 其他cookie...</code></pre></div><p>现在，还剩下最后一个问题，就是如何删除浏览器的一个cookie呢？</p><p><br></p><p>如果要删除浏览器的cookie，只需要让服务器响应一个同样的域、同样的路径、同样的key，只是时间过期的cookie即可</p><p><br></p><p><strong>所以，删除cookie其实就是修改cookie</strong></p><p><br></p><p>下面的响应会让浏览器删除<code data-backticks=\"1\">token</code></p><div data-language=\"yaml\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"yaml\">cookie: token=; domain=yuanjin.tech; path=/; max-age=-1</code></pre></div><p>浏览器按照要求修改了cookie后，会发现cookie已经过期，于是自然就会删除了。</p><blockquote><p>无论是修改还是删除，都要注意cookie的域和路径，因为完全可能存在域或路径不同，但key相同的cookie</p><p><br></p><p>因此无法仅通过key确定是哪一个cookie</p></blockquote><h2 id=\"客户端设置cookie\">客户端设置cookie</h2><p>既然cookie是存放在浏览器端的，所以浏览器向JS公开了接口，让其可以设置cookie</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">document.cookie = \"键=值; path=?; domain=?; expire=?; max-age=?; secure\";</code></pre></div><p>可以看出，在客户端设置cookie，和服务器设置cookie的格式一样，只是有下面的不同</p><ul><li><p>没有httponly。因为httponly本来就是为了限制在客户端访问的，既然你是在客户端配置，自然失去了限制的意义。</p></li><li><p>path的默认值。在服务器端设置cookie时，如果没有写path，使用的是请求的path。而在客户端设置cookie时，也许根本没有请求发生。因此，path在客户端设置时的默认值是当前网页的path</p></li><li><p>domain的默认值。和path同理，客户端设置时的默认值是当前网页的domain</p></li><li><p>其他：一样</p></li><li><p>删除cookie：和服务器也一样，修改cookie的过期时间即可</p></li></ul><h1 id=\"总结\">总结</h1><p>以上，就是cookie原理部分的内容。</p><p><br></p><p>如果把它用于登录场景，就是如下的流程：</p><p><br></p><p><strong>登录请求</strong></p><ol><li><p>浏览器发送请求到服务器，附带账号密码</p></li><li><p>服务器验证账号密码是否正确，如果不正确，响应错误，如果正确，在响应头中设置cookie，附带登录认证信息（至于登录认证信息是设么样的，如何设计，要考虑哪些问题，就是另一个话题了，可以百度 jwt）</p></li><li><p>客户端收到cookie，浏览器自动记录下来</p></li></ol><p><strong>后续请求</strong></p><ol><li><p>浏览器发送请求到服务器，希望添加一个管理员，并将cookie自动附带到请求中</p></li><li><p>服务器先获取cookie，验证cookie中的信息是否正确，如果不正确，不予以操作，如果正确，完成正常的业务流程</p></li></ol>', '/static/uploads/cookie1660805409280291116613108521116693.png', 42, 0, '1634959808000', 3);
INSERT INTO `blog` VALUES (18, '浅谈JWT', 'jwt全称`Json Web Token`，强行翻译过来就是`json格式的互联网令牌`', '[{\"name\":\"概述\",\"anchor\":\"概述\",\"level\":1,\"children\":[]},{\"name\":\"令牌的组成\",\"anchor\":\"令牌的组成\",\"level\":1,\"children\":[{\"name\":\"header\",\"anchor\":\"header\",\"level\":2,\"children\":[]},{\"name\":\"payload\",\"anchor\":\"payload\",\"level\":2,\"children\":[]},{\"name\":\"signature\",\"anchor\":\"signature\",\"level\":2,\"children\":[]}]},{\"name\":\"令牌的验证\",\"anchor\":\"令牌的验证\",\"level\":1,\"children\":[]},{\"name\":\"总结\",\"anchor\":\"总结\",\"level\":1,\"children\":[]}]', '<p>随着前后端分离的发展，以及数据中心的建立，越来越多的公司会创建一个中心服务器，服务于各种产品线。</p>', '/static/uploads/ceeb653ely1g0qlr7zuyfg20dc0anq3y16613110545038021.gif', 24, 0, '1640230208000', 3);
INSERT INTO `blog` VALUES (19, 'CORS跨域方案', '`CORS`是基于`http1.1`的一种跨域解决方案，它的全称是Cross-Origin Resource Sharing，跨域资源共享。', '[{\"name\":\"JSONP\",\"anchor\":\"jsonp\",\"level\":1,\"children\":[]},{\"name\":\"概述\",\"anchor\":\"概述\",\"level\":1,\"children\":[]},{\"name\":\"简单请求\",\"anchor\":\"简单请求\",\"level\":1,\"children\":[{\"name\":\"简单请求的判定\",\"anchor\":\"简单请求的判定\",\"level\":2,\"children\":[]},{\"name\":\"简单请求的交互规范\",\"anchor\":\"简单请求的交互规范\",\"level\":2,\"children\":[]}]},{\"name\":\"需要预检的请求\",\"anchor\":\"需要预检的请求\",\"level\":1,\"children\":[]},{\"name\":\"附带身份凭证的请求\",\"anchor\":\"附带身份凭证的请求\",\"level\":1,\"children\":[]},{\"name\":\"一个额外的补充\",\"anchor\":\"一个额外的补充\",\"level\":1,\"children\":[]}]', '<h1 id=\"jsonp\">JSONP</h1><p>在谈<code data-backticks=\"1\">CORS</code>之前我们先来简单说一下JSONP</p><p>一些老项目还存用JSONP来解决浏览器跨域问题但是,JSONP并不是一个好的跨域解决方案，它至少有着下面两个严重问题：</p><ol><li><p><strong>会打乱服务器的消息格式</strong>：JSONP要求服务器响应一段JS代码，但在非跨域的情况下，服务器又需要响应一个正常的JSON格式</p></li><li><p><strong>只能完成GET请求</strong>：JSONP的原理会要求浏览器端生成一个<code data-backticks=\"1\">script</code>元素，而<code data-backticks=\"1\">script</code>元素发出的请求只能是<code data-backticks=\"1\">get</code>请求</p></li></ol><p>所以，CORS是一种更好的跨域解决方案。</p><h1 id=\"概述\">概述</h1><p><code data-backticks=\"1\">CORS</code>是基于<code data-backticks=\"1\">http1.1</code>的一种跨域解决方案，它的全称是<strong>C</strong>ross-<strong>O</strong>rigin <strong>R</strong>esource <strong>S</strong>haring，跨域资源共享。</p><p><br></p><p>它的总体思路是：<strong>如果浏览器要跨域访问服务器的资源，需要获得服务器的允许</strong></p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/image-20200421152122793.png\" alt=\"image-20200421152122793\" contenteditable=\"false\"><br></p><p><br></p><p>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p><p><br></p><p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p><p><br></p><p>针对不同的请求，CORS规定了三种不同的交互模式，分别是：</p><ul><li><p><strong>简单请求</strong></p></li><li><p><strong>需要预检的请求</strong></p></li><li><p><strong>附带身份凭证的请求</strong></p></li></ul><p>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。</p><p><br></p><p>下面分别说明三种请求模式的具体规范。</p><h1 id=\"简单请求\">简单请求</h1><p>当浏览器端运行了一段ajax代码（无论是使用XMLHttpRequest还是fetch api），浏览器会首先判断它属于哪一种请求模式</p><h2 id=\"简单请求的判定\">简单请求的判定</h2><p>当请求<strong>同时满足</strong>以下条件时，浏览器会认为它是一个简单请求：</p><ol><li><p><strong>请求方法属于下面的一种：</strong></p><ul><li><p>get</p></li><li><p>post</p></li><li><p>head</p></li></ul></li><li><p><strong>请求头仅包含安全的字段，常见的安全字段如下：</strong></p><ul><li><p><code data-backticks=\"1\">Accept</code></p></li><li><p><code data-backticks=\"1\">Accept-Language</code></p></li><li><p><code data-backticks=\"1\">Content-Language</code></p></li><li><p><code data-backticks=\"1\">Content-Type</code></p></li><li><p><code data-backticks=\"1\">DPR</code></p></li><li><p><code data-backticks=\"1\">Downlink</code></p></li><li><p><code data-backticks=\"1\">Save-Data</code></p></li><li><p><code data-backticks=\"1\">Viewport-Width</code></p></li><li><p><code data-backticks=\"1\">Width</code></p></li></ul></li><li><p><strong>请求头如果包含<code data-backticks=\"1\">Content-Type</code>，仅限下面的值之一：</strong></p><ul><li><p><code data-backticks=\"1\">text/plain</code></p></li><li><p><code data-backticks=\"1\">multipart/form-data</code></p></li><li><p><code data-backticks=\"1\">application/x-www-form-urlencoded</code></p></li></ul></li></ol><p>如果以上三个条件同时满足，浏览器判定为简单请求。</p><p><br></p><p>下面是一些例子：</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 简单请求\nfetch(\"http://crossdomain.com/api/news\");\n\n// 请求方法不满足要求，不是简单请求\nfetch(\"http://crossdomain.com/api/news\", {\n  method:\"PUT\"\n})\n\n// 加入了额外的请求头，不是简单请求\nfetch(\"http://crossdomain.com/api/news\", {\n  headers:{\n    a: 1\n  }\n})\n\n// 简单请求\nfetch(\"http://crossdomain.com/api/news\", {\n  method: \"post\"\n})\n\n// content-type不满足要求，不是简单请求\nfetch(\"http://crossdomain.com/api/news\", {\n  method: \"post\",\n  headers: {\n    \"content-type\": \"application/json\"\n  }\n})</code></pre></div><h2 id=\"简单请求的交互规范\">简单请求的交互规范</h2><p>当浏览器判定某个<strong>ajax跨域请求</strong>是<strong>简单请求</strong>时，会发生以下的事情</p><ol><li><p><strong>请求头中会自动添加<code data-backticks=\"1\">Origin</code>字段</strong></p></li></ol><p>比如，在页面<code data-backticks=\"1\">http://my.com/index.html</code>中有以下代码造成了跨域</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 简单请求\nfetch(\"http://crossdomain.com/api/news\");</code></pre></div><p>请求发出后，请求头会是下面的格式：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>GET /api/news/ HTTP/1.1\nHost: crossdomain.com\nConnection: keep-alive\n...\nReferer: http://my.com/index.html\nOrigin: http://my.com</code></pre></div><p>看到最后一行没，<code data-backticks=\"1\">Origin</code>字段会告诉服务器，是哪个源地址在跨域请求</p><ol start=\"2\"><li><p><strong>服务器响应头中应包含<code data-backticks=\"1\">Access-Control-Allow-Origin</code></strong></p></li></ol><p>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加<code data-backticks=\"1\">Access-Control-Allow-Origin</code>字段</p><p><br></p><p>该字段的值可以是：</p><ul><li><p>*：表示我很开放，什么人我都允许访问</p></li><li><p>具体的源：比如<code data-backticks=\"1\">http://my.com</code>，表示我就允许你访问</p></li></ul><blockquote><p>实际上，这两个值对于客户端<code data-backticks=\"1\">http://my.com</code>而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</p><p><br></p><p>当然，服务器也可以维护一个可被允许的源列表，如果请求的<code data-backticks=\"1\">Origin</code>命中该列表，才响应<code data-backticks=\"1\">*</code>或具体的源</p><p><br></p><p><strong>为了避免后续的麻烦，强烈推荐响应具体的源</strong></p></blockquote><p>假设服务器做出了以下的响应：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>HTTP/1.1 200 OK\nDate: Tue, 21 Apr 2020 08:03:35 GMT\n...\nAccess-Control-Allow-Origin: http://my.com\n...\n\n消息体中的数据</code></pre></div><p>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给js，以完成后续的操作</p><p><br></p><p>下图简述了整个交互过程</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/image-20200421162846480.png\" alt=\"image-20200421162846480\" contenteditable=\"false\"><br></p><h1 id=\"需要预检的请求\">需要预检的请求</h1><p>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。</p><p><br></p><p>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p><ol><li><p><strong>浏览器发送预检请求，询问服务器是否允许</strong></p></li><li><p><strong>服务器允许</strong></p></li><li><p><strong>浏览器发送真实请求</strong></p></li><li><p><strong>服务器完成真实的响应</strong></p></li></ol><p>比如，在页面<code data-backticks=\"1\">http://my.com/index.html</code>中有以下代码造成了跨域</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// 需要预检的请求\nfetch(\"http://crossdomain.com/api/user\", {\n  method:\"POST\", // post 请求\n  headers:{  // 设置请求头\n    a: 1,\n    b: 2,\n    \"content-type\": \"application/json\"\n  },\n  body: JSON.stringify({ name: \"袁小进\", age: 18 }) // 设置请求体\n});</code></pre></div><p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p><ol><li><p><strong>浏览器发送预检请求，询问服务器是否允许</strong></p></li></ol><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>OPTIONS /api/user HTTP/1.1\nHost: crossdomain.com\n...\nOrigin: http://my.com\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: a, b, content-type</code></pre></div><p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的响应头，也没有消息体。</p><p><br></p><p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p><p><br></p><p>预检请求<strong>没有请求体</strong>，它包含了后续真实请求要做的事情</p><p><br></p><p>预检请求有以下特征：</p><ul><li><p>请求方法为<code data-backticks=\"1\">OPTIONS</code></p></li><li><p>没有请求体</p></li><li><p>请求头中包含</p><ul><li><p><code data-backticks=\"1\">Origin</code>：请求的源，和简单请求的含义一致</p></li><li><p><code data-backticks=\"1\">Access-Control-Request-Method</code>：后续的真实请求将使用的请求方法</p></li><li><p><code data-backticks=\"1\">Access-Control-Request-Headers</code>：后续的真实请求会改动的请求头</p></li></ul></li></ul><ol start=\"2\"><li><p><strong>服务器允许</strong></p></li></ol><p>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>HTTP/1.1 200 OK\nDate: Tue, 21 Apr 2020 08:03:35 GMT\n...\nAccess-Control-Allow-Origin: http://my.com\nAccess-Control-Allow-Methods: POST\nAccess-Control-Allow-Headers: a, b, content-type\nAccess-Control-Max-Age: 86400\n...</code></pre></div><p>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p><ul><li><p><code data-backticks=\"1\">Access-Control-Allow-Origin</code>：和简单请求一样，表示允许的源</p></li><li><p><code data-backticks=\"1\">Access-Control-Allow-Methods</code>：表示允许的后续真实的请求方法</p></li><li><p><code data-backticks=\"1\">Access-Control-Allow-Headers</code>：表示允许改动的请求头</p></li><li><p><code data-backticks=\"1\">Access-Control-Max-Age</code>：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</p></li></ul><ol start=\"3\"><li><p><strong>浏览器发送真实请求</strong></p></li></ol><p>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>POST /api/user HTTP/1.1\nHost: crossdomain.com\nConnection: keep-alive\n...\nReferer: http://my.com/index.html\nOrigin: http://my.com\n\n{\"name\": \"袁小进\", \"age\": 18 }</code></pre></div><ol start=\"4\"><li><p><strong>服务器响应真实请求</strong></p></li></ol><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>HTTP/1.1 200 OK\nDate: Tue, 21 Apr 2020 08:03:35 GMT\n...\nAccess-Control-Allow-Origin: http://my.com\n...\n\n添加用户成功</code></pre></div><p>可以看出，当完成预检之后，后续的处理与简单请求相同</p><p><br></p><p>下图简述了整个交互过程</p><p><br></p><p><img src=\"http://mdrs.yuanjin.tech/img/image-20200421165913320.png\" alt=\"image-20200421165913320\" contenteditable=\"false\"><br></p><h1 id=\"附带身份凭证的请求\">附带身份凭证的请求</h1><p>默认情况下，ajax的跨域请求并不会附带cookie，这样一来，某些需要权限的操作就无法进行</p><p><br></p><p>不过可以通过简单的配置就可以实现附带cookie</p><div data-language=\"js\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"js\">// xhr\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\n// fetch api\nfetch(url, {\n  credentials: \"include\"\n})</code></pre></div><p>这样一来，该跨域的ajax请求就是一个<em>附带身份凭证的请求</em></p><p><br></p><p>当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加<code data-backticks=\"1\">cookie</code>字段</p><p><br></p><p>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据</p><p><br></p><p>告知的方式也非常的简单，只需要在响应头中添加：<code data-backticks=\"1\">Access-Control-Allow-Credentials: true</code>即可</p><p><br></p><p>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。</p><p><br></p><p>另外要特别注意的是：<strong>对于附带身份凭证的请求，服务器不得设置 <code data-backticks=\"1\">Access-Control-Allow-Origin 的值为*</code></strong>。这就是为什么不推荐使用*的原因</p><h1 id=\"一个额外的补充\">一个额外的补充</h1><p>在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><br></p><p><code data-backticks=\"1\">Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p><div data-language=\"text\" class=\"toastui-editor-ww-code-block\"><pre><code>Access-Control-Expose-Headers: authorization, a, b</code></pre></div><p>这样JS就能够访问指定的响应头了。</p>', '/static/uploads/ceeb653ely8h07ilhvmnwg20dw09l76716613115132496220.gif', 49, 1, '1654741808000', 3);

-- ----------------------------
-- Table structure for blogType
-- ----------------------------
DROP TABLE IF EXISTS `blogType`;
CREATE TABLE `blogType`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `articleCount` int(0) NOT NULL,
  `order` int(0) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blogType
-- ----------------------------
INSERT INTO `blogType` VALUES (1, 'JS', 7, 1);
INSERT INTO `blogType` VALUES (2, 'CSS', 2, 1);
INSERT INTO `blogType` VALUES (3, 'NODE', 3, 1);
INSERT INTO `blogType` VALUES (4, 'VUE', 4, 1);
INSERT INTO `blogType` VALUES (5, 'HTML', 3, 1);

-- ----------------------------
-- Table structure for demo
-- ----------------------------
DROP TABLE IF EXISTS `demo`;
CREATE TABLE `demo`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `github` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `thumb` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `order` int(0) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 22 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of demo
-- ----------------------------
INSERT INTO `demo` VALUES (2, '文字滚动效果', 'http://182.92.67.46/demo/01/', '..', '[\"使用原生js编写电商网站中经常出现的\",\"广告文字向上轮播滚动功能\"]', '/static/uploads/006qOO1Xly1grdi7it9zeg308c07iwlr (1)16612448662903203.gif', 1);
INSERT INTO `demo` VALUES (3, '手风琴效果', 'http://182.92.67.46/demo/02/', '..', '[\"手风琴效果的特点：每次只展开一个元素，其他的兄弟元素都闭合\"]', '/static/uploads/9e31678cgy1ftf95amdu5g208c08cahb16612453735067626.gif', 1);
INSERT INTO `demo` VALUES (4, '动态排序表格', 'http://182.92.67.46/demo/03/', '。。', '[\"在传统表格的功能基础上增加以下功能:\",\"1 为每一行增加复选框，标题行单独添加，根据其他选中行的状态进行全选/全取消  \",\"2 点击某列标题，并相对该列进行升序排序\"]', '/static/uploads/006APoFYly8gvwovuy0w2j30hs0hsjs3 (1)16612457150739686.jpg', 1);
INSERT INTO `demo` VALUES (5, '实现三级联动效果', 'http://182.92.67.46/demo/04/', '。。', '[\"对省>市>学校通过三个下拉栏进行联动选择，当选择好省位置后，市的下拉栏内容相对被选中省更新，学校类似。\"]', '/static/uploads/006APoFYly8h4hgddri4tj306o06ojrc16612471600074680.jpg', 1);
INSERT INTO `demo` VALUES (6, '腾讯视频重磅推荐模块', 'http://182.92.67.46/demo/05/', '...', '[\"多个文字标题循环间隔激活，被激活的文字联动banner图片切换\"]', '/static/uploads/006APoFYly8h4o30qeuwpj30c80bsmxp16612481384568569.jpg', 1);
INSERT INTO `demo` VALUES (7, '图片放大镜', 'http://182.92.67.46/demo/06/', '。。。', '[\"过将鼠标指向指定的图片，将鼠标移动到图片时显示一个透明的小区域然后将小区域的部分放大查看细节\"]', '/static/uploads/005J4OU5ly1h4g1xmeebfj30u00s675v16612487312636610.jpg', 1);
INSERT INTO `demo` VALUES (8, '积分抽奖效果', 'http://182.92.67.46/demo/07/', '...', '[\"点击按钮开始随机抽取奖品，滚动被选中的奖品\"]', '/static/uploads/a7c49da7ly1frqd16vvizj20b40b474n16612556834095139.jpg', 1);
INSERT INTO `demo` VALUES (9, '倒计时', 'http://182.92.67.46/demo/08/', '..', '[\"通过滚动数字图片实现24小时倒计时功能\"]', '/static/uploads/ceeb653ely8h2uljzhepnj20hs0gk3z8 (1)16612527553507119.jpg', 1);
INSERT INTO `demo` VALUES (10, '无缝轮播图', 'http://182.92.67.46/demo/09/', '...', '[\"平时项目开发中都是用UI库提供的轮播图组件，于是想尝试自己封装一个无缝轮播图组件\"]', '/static/uploads/006qir4oly1gt51oid1yhj309i08owep16612530971622205.jpg', 1);
INSERT INTO `demo` VALUES (11, '图片瀑布流', 'http://182.92.67.46/demo/10/', '。。。。', '[\"现实中我们的图片宽高大小不一定总是一致的，如果强行用代码将所有图片调成一样的宽高会出来图片质量受损\",\"为了解决这个问题，可以通过图片瀑布流方式进行图片布局，并自适应屏幕大小\",\"来最大化利用空间\"]', '/static/uploads/0085wA6egy1h4cm99tpxgj30qy0peq4816612535126672655.jpg', 1);
INSERT INTO `demo` VALUES (12, '分页插件', 'http://182.92.67.46/demo/11/', '。。。', '[\"当需要给用户显示大量数据内容时，通过分页组件，来完成分批次请求\"]', '/static/uploads/006szvLFgy1fwll8fpyzdj30b407dq5d (1)16612556667591019.jpg', 1);
INSERT INTO `demo` VALUES (13, '五子棋游戏', 'http://182.92.67.46/demo/12/', '。。。', '[\"骚年买挂吗？\"]', '/static/uploads/006hL0SXgy1g82gztyrxxg30800e8kjs (1)16612567610782750.gif', 1);
INSERT INTO `demo` VALUES (14, '读心术小游戏', 'http://182.92.67.46/demo/13/', '...', '[\"心机之蛙，一直摸你肚子\"]', '/static/uploads/006r3PQBjw1f967hkjzcvj30hs0hs3zk16612568418192203.jpg', 1);
INSERT INTO `demo` VALUES (15, '图片拖动验证', 'http://182.92.67.46/demo/14/', '...', '[\"传统的图片验证，在面对如今的ai算法是很容易被识别出来的\",\"这样导致可以通过登录注册这种对外公布的接口，对服务发起攻击，而在前端使用图片拖动验证登录\",\"能有效的进行预防\"]', '/static/uploads/0073Cjx6gy1gwlxwpifjjg306o06dhc316612569374764642.gif', 1);
INSERT INTO `demo` VALUES (16, '歌词滚动', 'http://182.92.67.46/demo/15/', '...', '[\"使用H5-video标签进行音频播放\",\"歌词以向上滚动的形式与音频同步\",\"拖动音频进度，歌词同样滚动到相对应位置\"]', '/static/uploads/006Mi9iRgy1gqvuas1g7qg308c08c75b16612579928244901.gif', 1);
INSERT INTO `demo` VALUES (17, '王者荣耀官网英雄查询', 'http://182.92.67.46/demo/16/', '。。。', '[\"使用网格布局，对英雄图标进行布局\",\"对获取的英雄数据根据一些特定的属性值在前端进行分类处理，来完成用户点击类型搜索，和输入关键字搜索功能，这样能有效减轻服务器压力\"]', '/static/uploads/20190614091735_4985816612581228187197.jpg', 1);
INSERT INTO `demo` VALUES (18, '美团省市级联', 'http://182.92.67.46/demo/17/', '...', '[\"通过网格布局\",\"自定义一个下拉列表\",\"完成省市级联动功能\"]', '/static/uploads/005PeXV6gy1gk5ew08qysj30m80m8jtx16612588149836582.jpg', 1);
INSERT INTO `demo` VALUES (19, '豆豉', 'http://182.92.67.46/demo/18/', '...', '[\"1.使用webpack打包工具对项目进行工程化管理\",\"2.手动封装分页组件，对电影内容进行分页 3.通过video标签完成个性化交互\"]', '/static/uploads/68611fd2gy1fwp64d0u9bj213d13d40i16612595187252564.jpg', 1);
INSERT INTO `demo` VALUES (20, 'Todos', 'http://182.92.67.46/demo/19/', '..', '[\" \"]', '/static/uploads/006HkbLkly1g8bdls1m0dj30c80c80tq16612672361908879.jpg', 1);
INSERT INTO `demo` VALUES (21, 'VUE3-GDP可视化响应表格', 'http://182.92.67.46/demo/20/', '...', '[\"\"]', '/static/uploads/994b6f2egy1fy3njeysg4g2064075qv516612677520524797.gif', 1);

-- ----------------------------
-- Table structure for message
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `createDate` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `blogId` int(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `blogId`(`blogId`) USING BTREE,
  CONSTRAINT `message_ibfk_1` FOREIGN KEY (`blogId`) REFERENCES `blog` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of message
-- ----------------------------
INSERT INTO `message` VALUES (1, '加缪', '我们很少信任比我们好的人，宁肯避免与他们来往。相反，我们常对与我们相似、和我们有着共同弱点的人来吐露心迹。我们并不希望改掉弱点，只希望收到怜悯与鼓励', '1661224794628', '/static/avatar/ohmygood.gif', NULL);
INSERT INTO `message` VALUES (2, '马克·奥勒留', '人们相互蔑视，又相互奉承，人们各自希望自己高于别人，又各自匍匐在别人面前。', '1661224808250', '/static/avatar/rainbow.gif', NULL);
INSERT INTO `message` VALUES (3, '李娟', '大家都愿意盲从，好像世界上最安全的事就是让自己消失在“多数”之中。', '1661224816491', '/static/avatar/ohmygood.gif', NULL);
INSERT INTO `message` VALUES (4, '罗素', '乞丐不会妒忌百万富翁', '1661224824369', '/static/avatar/looklook.png', NULL);
INSERT INTO `message` VALUES (5, '王尔德', '一个人总是可以善待他毫不在意的人。', '1661224863643', '/static/avatar/ohmygood.gif', NULL);
INSERT INTO `message` VALUES (6, '伊坂幸太郎', '四平八稳的日子里，谁都能讲出几句大道理。主张人权，占领道德高地很简单。但当暴风雨来临之时，人们就慌了手脚，再无力顾及所谓的正确，只能随波逐流。人就是这样。', '1661225036185', '/static/avatar/happy.gif', NULL);
INSERT INTO `message` VALUES (7, '老舍', '我们创造了一种独具风格的生活方式：有钱的真讲究，没钱的穷讲究。生命就这么沉浮在有讲究的一汪死水里。', '1661225061630', '/static/avatar/whatthat.png', NULL);
INSERT INTO `message` VALUES (8, '路遥', '人们宁愿去关心一个蹩脚电影演员的吃喝拉撒和鸡毛蒜皮，而不愿了解一个普通人波涛汹涌的内心世界。', '1661225082515', '/static/avatar/miao.png', NULL);
INSERT INTO `message` VALUES (9, '尼尔·波兹曼', '“娱乐至死”的可怕之处不在于娱乐本身，而在于人们日渐失去对社会事务的严肃思考和理智判断的能力，在于被轻佻的文化环境培养成了既无知且无畏的理性文盲而不自知。', '1661225115586', '/static/avatar/yeah.png', NULL);
INSERT INTO `message` VALUES (10, '史铁生', '人与人的交往多半肤浅，或只有在较为肤浅的层面上，交往才是容易的，一旦走进深处，人与人就是相互的迷宫。', '1661225143105', '/static/avatar/looklook.png', NULL);
INSERT INTO `message` VALUES (11, '威廉·詹姆斯', '很多人觉得他们在思考，而实际上他们只是在重新整理自己的偏见。', '1661225167070', '/static/avatar/rainbow.gif', NULL);
INSERT INTO `message` VALUES (12, '钱钟书', '偏见可以说是思想的放假，它是没有思想的人的日常家用，是有思想的人的星期日娱乐。', '1661225195317', '/static/avatar/ohmygood.gif', NULL);
INSERT INTO `message` VALUES (13, '张方宇', '很少人会真正的去爱别人，人们只是想借着给出一点爱而获得爱，那是一种垂钓。', '1661225240611', '/static/avatar/scare.gif', NULL);
INSERT INTO `message` VALUES (14, '王尔德', '我年青时以为金钱至上，而今年事已迈，发现果真如此。', '1661225258256', '/static/avatar/looklook.png', NULL);
INSERT INTO `message` VALUES (15, '詹姆斯·索特', '不管有意无意，我们全都是极其自私的，只要我们得到自己想要的东西，就会认为一切都好。', '1661225275472', '/static/avatar/ohmygood.gif', NULL);
INSERT INTO `message` VALUES (16, '纳尔逊.曼德拉', '可以卑微如尘土，不可扭曲如蛆虫。', '1661225346687', '/static/avatar/yeah.png', NULL);
INSERT INTO `message` VALUES (17, '闵玧其', '指南针在指向正确方向之前，总是先摆动几次。', '1661225374558', '/static/avatar/666.png', NULL);
INSERT INTO `message` VALUES (18, '卡耶塔诺·费洛索', '近看之下，没有人是正常的。', '1661225486158', '/static/avatar/yeah.png', NULL);
INSERT INTO `message` VALUES (19, '三毛', '人生最可贵的事情，就是少年的迷茫。', '1661225499692', '/static/avatar/ohmygood.gif', NULL);
INSERT INTO `message` VALUES (21, 'CCYX', '保持飞行', '1661317191321', '/static/avatar/666.png', 11);
INSERT INTO `message` VALUES (22, 'AXS', '垂涎三尺', '1661325453430', '/static/avatar/scare.gif', 19);

-- ----------------------------
-- Table structure for setting
-- ----------------------------
DROP TABLE IF EXISTS `setting`;
CREATE TABLE `setting`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `siteTitle` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `github` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `qq` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `qqQrCode` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `weixin` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `weixinQrCode` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `mail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `icp` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `githubName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `favicon` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of setting
-- ----------------------------
INSERT INTO `setting` VALUES (1, '/static/images/lf.gif', 'JS.D.HX', 'https://github.com/echo-huxin', '1611012508', '/static/images/qqCode.jpg', 'hustle-hx', '/static/images/wxCode.jpg', 'wb4425883@163.com', '源ICP备1024号', 'echo-huxin', 'https://s2.loli.net/2022/08/18/roWO1DM8zXYqSBN.png');

SET FOREIGN_KEY_CHECKS = 1;
